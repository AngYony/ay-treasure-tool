# Redis 分布式锁

实现分布式锁，需要解决的问题：

- 互斥性，值的获取和设置必须是原子性的操作
- 死锁，长时间未释放锁，如何安全的释放锁资源
- 安全性，锁只能被持有该锁的用户删除，不能被其他用户删除
- 分布式锁在集群中的问题



## 原子性操作

分布式锁的实现原理，简单来说，就是判断某个key是否存在且值为1 ，这个key一般是全局唯一ID。

判断key是否存在且值为1 ，一般情况，该过程分为两步：

- 判断key是否有值且为1
- 如果不是，则设为1

由于这两个操作不是原子性的，在高并发的情况下，很容易出问题，为了解决这个问题，必须使用Redis 的==Setnx==来设置值，从而保证原子性。

==总结：重点就是 Setnx，将获取和设置值变成原子性的操作。==



## 锁释放

正常情况下，在获取到锁后，当业务程序执行完成之后，应当删除该key来释放锁。

长时间未释放锁，导致别人永远获取不到锁的原因有：

1. 业务逻辑处理时发生意外，可能是bug，也可能是服务器宕机
2. 业务逻辑执行时间过长

解决1中情况，通常通过设置过期时间来解决；

设置过期时间也必须是原子性操作，因此通常通过使用Redis的Lua脚本来实现过期时间的设置，如下所示：

```lua
if redis.call("GET", KEYS[1]) == ARGV[1] then
	return redis.call("PEXPIRE", KEYS[1], ARGV[2])
else
	return 0
end
```

解决2中情况，只是简单设置过期时间还不行，假如设置的过期时间小于程序正常执行完所需的时间，此时就需要不断通过重新设置过期时间来延时，但不断的延时，会导致别人永远无法获取到锁。



## 安全性

分布式锁必须要保证安全性，即：锁只能被持有该锁的用户删除，不能被其他用户删除。

实现方式就是：为key设置值时，不是单纯的设置为1，而是设置一个随机值，一个别人不知道的值，每当删除key的时候，都要先判断一下值是否由其创建的，而不是别人改过的。（当时设置的value值是多少，只有当时的groutine知道，在删除的时候，取出redis中的值和当前自己保存下来的值对比一下，是之前的值才删除）

相关的lua脚本：

```lua
if redis.call("GET", KEYS[1]) == ARGV[1] then
	return redis.call("DEL", KEYS[1])
else
	return 0
end
```



## 分布式锁在集群中的问题

单台redis可以通过上述方法进行解决，但在集群中，多台redis因为某种原因，比如网络故障，导致每台redis数据同步之间出现了问题，就会出现锁异常。解决方式是，引入redlock。

时钟漂移问题？



### redlock

核心原理：

5台机器，谁先竞争获取到3台服务器的锁，谁就胜出。



 


# 幂等性

幂等与你是不是分布式高并发没有关系。关键是你的操作是不是幂等的。

一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。

一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。

简单来说，就是同样的数据提交两次，或因为重试机制调用了多次，数据库中只能有一份数据。

例如，网络卡顿，多次点击按钮等场景，就要保证幂等性。

如果允许consumer重试，那么provider就要能够做到幂等。

在重试机制的基础上，同一个请求被consumer多次调用，对provider产生的影响是一致的。而且这个幂等应该是服务级别的，而不是某台机器层面的，重试调用任何一台机器，都应该做到幂等。



## 常见幂等性解决方案

- 唯一索引，防止新增脏数据

  唯一索引或唯一组合索引来防止新增数据存在脏数据
  （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）

- token机制，防止页面重复提交

  - 业务要求：页面的数据只能被点击提交一次
  - 发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交
  - 解决办法：集群环境，采用token加redis（redis单线程的，处理需要排队）
  - 处理流程：
    1. 数据提交前要向服务的申请token，token放到redis或内存，token有效时间
    2. 提交后后台校验token，同时删除token，生成新的token返回
  - token特点：要申请，一次有效性，可以限流

  注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用。

- 锁机制

  - 悲观锁
  - 乐观锁
  - 分布式锁

- select + insert

  并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了
  **注意：核心高并发流程不要用这种方法**

- 对外提供接口的api如何保证幂等

  如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号
  source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)

  重点：
  对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。


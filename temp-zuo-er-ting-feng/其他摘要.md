# 左耳听风专栏摘要



> 我完全没有必要通过打工听人安排而活着，而是反过来通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活。
>
> ——《程序员如何用技术变现（上）》



------



> 因而，在工作当中，对于那些没什么技术含量的工作，我基本上就像是在学生时代那样交作业就好了。我想尽一切方法提高交作业的效率，比如，提高代码的重用度，能自动化的就自动化，和需求人员谈需求，简化掉需求，这样我就可以少干一些活了……
>
> 这样一来，我就可以有更多的时间，去研究公司里外那些更为核心更有技术含量的技术了。
>
> ——《程序员如何用技术变现（上）》



------



> 要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。
>
> 要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。
>
> 更重要的是，技术和知识完全是可以变现的。
>
> ——《程序员如何用技术变现（上）》



------



> 25~35 岁是每个人最宝贵的时光，应该用在刀刃上。
>
> ——《程序员如何用技术变现（上）》



------



> 千里之行，积于跬步。
>
> 具体说来，首先，你得让自己身边的人有求于你，或是向别人推荐你。这就需要你能够掌握大多数人不能掌握的技能或技术，需要你更多地学习，并要有更多的别人没有的经验和经历。
>
> ——《程序员如何用技术变现（下）》



------



> 关注有价值的东西。
>
> 供大于求，就没什么价值，供不应求，就有价值。
>
> 能够分辨出什么是主流技术，什么是过渡式的技术。
>
> 关于市场需求。真正缺的其实是有能力能够解决技术难题的人，能够提高团队人效的人。
>
> 关于技术趋势。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。
>
> ——《程序员如何用技术变现（下）》



------



> 找到有价值的信息源。
>
> 用好 Google 就是一个关键，比如你在 Google 搜索引擎里输入“XXX Best Practice”，或是“Best programming resource”……你就会找到很多。而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。
>
> ——《程序员如何用技术变现（下）》



------



> 你把时间投资在哪里，你的未来就在哪里；而你在什么样的圈里，你就会是什么样的人。
>
> ——《程序员如何用技术变现（下）》优质评论



------



> 说的直白一点，技术领导力就是，你还在用大刀长矛打战的时候，对方已经用上了洋枪大炮；你还在赶马车的时候，对方已经开上了汽车……
>
> ——《何为技术领导力》



------



> 技术领导力是：
>
> - 尊重技术，追求核心基础技术。
> - 追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。
> - 解放生产力，追逐人效的提高。
> - 开发抽象和高质量的可以重用的技术组件。
> - 坚持高于社会主流的技术标准和要求。
>
> ——《何为技术领导力》



------



> 作为一个软件工程师怎样才算是拥有“技术领导力”呢？
>
> - 能够发现问题。能够发现现有方案的问题。
>
> - 能够提供解决问题的思路和方案，并能比较这些方案的优缺点。
> - 能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。
>
> - 能够用更优雅，更简单，更容易的方式来解决问题。
> - 能够提高代码或软件的扩展性、重用性和可维护性。
> - 能够用正确的方式管理团队。。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。
> - 创新能力。能够使用新的方法新的方式解决问题，追逐新的工具和技术。
>
> ——《何为技术领导力》



------



> 一句话，总是在提供解决问题的思路和方案的人才是有技术领导力的人。
>
> ——《何为技术领导力》



------



如何让自己拥有技术领导力？

> - 扎实的基础技术。
> - 非同一般的学习能力。
> - 坚持做正确的事。
> - 不断提高对自己的要求标准。
>
> ——《何为技术领导力》



------



> 永远不要待在舒适区，主动进入学习区，重复工作尽量自动化，去研究别人不知道的新知识，这样才能具备强大的技术领导力，做一个真正优雅的极客~
>
> ——《何为技术领导力》优质评论



------



怎样才能拥有技术领导力？

> - 第一，你要吃透基础技术。基础技术是各种上层技术共同的基础。基础技术分为两个部分：
>
>   - 编程
>     - C语言，推荐书籍《C程序设计语言（第2版）》
>     - 编程范式（面向对象编程、泛型编程、函数式编程等）
>     - 算法和数据结构
>   - 系统
>     - 计算机系统原理，推荐书籍《深入理解计算机系统》
>     - 操作系统原理和基础，推荐《UNIX 环境高级编程》、《UNIX 网络编程》和《Windows核心编程》
>     - 网络基础，推荐书籍《TCP/IP详解》
>     - 数据库原理
>     - 分布式技术架构
> - 第二，提高学习能力。所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力。下面是让你提升学习能力的一些做法。
> - - 学习的信息源。常见的信息源有 Google 等搜索引擎，Stack Overflow、Quora 等社区，图书，API 文档，论文和博客等。
>   - 与高手交流。
>   - 举一反三的思考。
>   - 不怕困难的态度。绝大多数人是害怕困难的，所以，如果你能够不怕困难，并可以找到解决困难的方法和路径，时间一长，你就能拥有别人所不能拥有的能力。
>   - 开发的心态。实现一个目的通常有多种办法。带有开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。
> - 第三，坚持做正确的事。做正确的事，比用正确的方式做事更重要，因为这样才始终会向目的地靠拢。做正确的事有：
>   - 提高效率的事。
>   - 自动化的事。
>   - 掌握前沿技术的事。
>   - 知识密集型的事。
>   - 技术驱动的事。
> - 第四，高标准要求自己。只有不断地提高标准 ，你才可能越走越高，所以，要以高标准要求自己，不断地反思、总结和审视自己，才能够提升自己。
>   - Google 的自我评分卡。
>   - 敏锐的技术嗅觉。
>   - 强调实践，学以致用。
>   - Lead by Example。永远在编程。不写代码，你就对技术细节不敏感，你无法做出可以实践的技术决策和方案。
>
> ——《如何才能拥有技术领导力？》



------



程序员必看书单：

> - 《程序员修炼之道》
> - 《计算机的构造和解释》
> - 《算法导论》
> - 《设计模式》
> - 《重构》
> - 《人月神话》
> - 《代码整洁之道》
>
> ——《推荐阅读：每个程序员都该知道的知识》



------



> PaaS 是一个被世界或是被产业界严重低估的平台。
>
> PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司。因为 PaaS 层的技术主要能解决下面这些问题。
>
> - 软件生产线的问题。持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS。
> - 分布式服务化的问题。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。
> - 提高服务的可用性 SLA。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。
> - 软件能力的复用。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。
>
> ——《Go语言，Docker和新技术》



------



> 客观地审视自己。如果你超过了身边的大多数人，你不妨选择得激进一些冒险一些，否则，还是按部就班地来吧。
>
> 确定自己想要什么。所谓“极端”，就是自己不会受到其它东西或其他人的影响，不会因为这条路上有人退出你会开始怀疑或者迷茫，也不会因为别的路上有人成功了，你就会羡慕。
>
> 注重长期的可能性，而不是短期的功利。
>
> 尽量关注自己会得到的东西，而不是自己会失去的东西。
>
> 不要和大众的思维方式一样。
>
> ——《答疑解惑：渴望、热情和选择》



------



> 很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题的出发点、思维方式、格局观、价值观等因素影响。这些才是最本源的东西，甚至可以定义成思维的“基因”。就我们程序员而言，我认为，编码能力很重要，但是技术视野、技术洞察力，以及我们如何用技术解决问题的能力更为重要。
>
> ——《答疑解惑：渴望、热情和选择》



------



> Leader 和 Boss 的不同：
>
> - Boss 是驱动员工，Leader 是指导员工。
> - Boss 制造畏惧，Leader 制造热情。
> - Boss 面对错误喜欢使用人事惩罚的手段，而 Leader 面对错误喜欢寻找解决问题的技术或管理方法。
> - Boss 只是知道怎么做，而 Leader 则是展示怎么做。
> - Boss 是用人，而 Leader 是发展人。
> - Boss 从团队收割成绩，而 Leader 则是给予团队成绩。
> - Boss 喜欢命令和控制（ Command + Control ），而 Leader 喜欢沟通和协作（ Communication + Cooperation ）。
> - Boss 喜欢说“给我上”，而 Leader 喜欢说“跟我上”。
>
> ——《如何成为一个大家愿意追随的Leader？》



------



如何成为众人愿意追随的 Leader？

> - 帮人解决问题。团队或身边大多数人都在问：“这个问题怎么办？”，而你总是能站出来告诉大家该怎么办。
>- 被人依赖。团队或身边大多数人在做比较关键的决定时，都会来找你咨询意见和想法。
> - 赢得他人的信任。对于信任来说，并不完全是别人相信你能做到某个事，还有别人愿意向你打开心扉，和你说他心里面最柔软的东西。而后者才是真正的信任。
> - 开放的心态 + 倾向性的价值观。对于新生事物要有开放的心态，对于每个人的观点都有开放的心态，但并不是要认同所有的观点和事情，成为一个油腔滑调的人。就价值观来说，还是需要由倾向性的。比如，我就倾向于不加班的文化，倾向于全栈，倾向于按职责分工而不是按技能分工，倾向于做一个 Leader 而不是 Boss，倾向于技术是第一生产力，倾向于 OKR 而不是 KPI……我的这些倾向性可以让别人更清楚地知道我是一个什么样的人，而不会对我琢磨不透，一会东一会西只会让人觉得你太油了，反而会产生距离感和厌恶感。我认为，倾向性的价值观是别人是否可以跟随你的一个基础。
> - Lead by Example。用自己的示例来 Lead，用自己的行为来向大家展示你的 Leadership。这就是说，你需要给大家做示范。很多时候，道理人人都知道，但未必人人都会做，知易行难，以身示范，一个示例会比讲一万遍道理都管用。
> - 要做一个有人愿意跟随的技术 Leader，你需要终身写代码，也就是所谓的 ABC – Always Be Coding。这样，你会得到更多的实际经验，能够非常明白一个技术方案的优缺点，实现复杂度，知道什么是 Best Practice，你的方案才会更具执行力和实践性。当有了执行力，你就会获得更多的成就，而这些成就反过来会让更多的人来跟随你。
> - 保持热情和冲劲。所谓的保持热情和冲劲，并不是自欺欺人，也不是文过饰非，因为掩耳盗铃、掩盖问题、强颜欢笑的方式根本不是热情。真正的热情和冲劲是，正视问题，正视不足，正视错误，从中进行反思和总结得到更好的解决方案，不怕困难，迎难而上。
> - 能够抓住重点，看透事物的本质。作为一个 Leader，能够抓住主要矛盾，看清事物的本质，给出清楚的观点或方向，简化复杂的事情，传道解惑、开启民智，让人豁然开朗、醍醐灌顶，才会让人追随之。
> - 描绘令人激动的方向，提供令人向住的环境。一个好的 Leader 一定会把每个人心中最真善美的东西呼唤出来，并且还能让人相信这是有机会有可能做到的。
> - 甘当铺路石，为他人创造机会。
> 
> ——《如何成为一个大家愿意追随的Leader？》



------



> - 对于我们并不期望会发生的事，我们可以使用异常捕捉；
> - 对于我们觉得可能会发生的事，使用返回码。
>
> ——《程序中的错误处理：错误返回码和异常捕捉》



------



错误处理的最佳实践：

> - **统一分类的错误字典。**即对可能发生的错误进行统一的分类，比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。
> - **同类错误的定义最好是可以扩展的。**
> - **定义错误的严重程度。**比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。
> - **错误日志的输出最好使用错误码，而不是错误信息。**错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。
> - **忽略错误最好有日志。**不然会给维护带来很大的麻烦。
> - **对于同一个地方不停的报错，最好不要都打到日志里。**不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。
> - **不要用错误处理逻辑来处理业务逻辑。**也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。
> - **对于同类的错误处理，用一样的模式。**比如，对于null对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。
> - **尽可能在错误发生的地方处理错误。**因为这样会让调用者变得更简单。
> - **向上尽可能地返回原始的错误。**如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。
> - **处理错误时，总是要清理已分配的资源。**这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。
> - **不推荐在循环体里处理错误。**这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。
> - **不要把大量的代码都放在一个 try 语句块内。**一个 try 语句块内的语句应该是完成一个简单单一的事情。
> - **为你的错误定义提供清楚的文档以及每种错误的代码示例。**如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。
> - **对于异步的方式，推荐使用 Promise 模式处理错误。**对于这一点，JavaScript 中有很好的实践。
> - **对于分布式的系统，推荐使用 APM 相关的软件。**尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。
>
> ——《程序中的错误处理：异步编程以及我的最佳实践》



------



如何管理时间？

> - 主动管理
>
>   - 如果你发现你的时间老是被别人打断，那么你就要告诉大家，我什么时间段在做什么事，请大家不要打扰我。（如果仍然被打扰，可以选择别处的空工位办公）
>   - 你要主动管理的不是你的时间，而是管理你的同事，管理你的信息。
>
> - 学会说“不”
>
>   - 当你面对做不到的需求时，你不要马上说这个需求做不到。需要先思考，在给出一个你觉得可以做到的方案。诀窍是：给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。
>
>   - 当你面对过于复杂的需求时，你不要说不。而是需要想一想为什么要这样做？你可以回复说，这个需求好复杂，我们能不能先干这个，再做那个，这样会更经济一些。这里的诀窍是——我不说我不能完全满足你，但我说我可以部分满足你。
>
>   - 当你面对时间完全不够的需求时，你也不要说不。有三个选择：
>
>     - 我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。
>     - 我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？
>     - 我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？
>
>     这里的诀窍是：我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，看似我给了需求方选择，实际上，我掌握了主动。
>
>     积极主动的态度下对于不合理的事讨价还价”。只有学会了说“不”，你才能够控制好你的时间。
>
> - 加班和开会
>
>   - 学会比较是项目延期的伤害大，还是线上故障的伤害大，是先苦后甜好，还是积压问题好。如果怎么做都要受伤害，那么两害相权取其轻。
>   - 开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。
>
> ——《时间管理：同扭曲时间的事儿抗争》



------



如何利用好自己的时间？

> - 学会投资自己的时间。把时间投资在有价值有意义的地方，你就会有“更多的时间”。
>   - 花时间学习基础知识，花时间读文档。只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。系统地学习一门技术是非常关键的，所以这个时间是值得投资的。
>   - 花时间在解放自己生产力的事上。在自动化、可配置、可重用、可扩展上要多花时间。
>   - 花时间在让自己成长的事上。成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。
>   - 花时间在建立高效的环境上。把自己的工作环境整理到自己喜欢的状态下。比如使用趁手的开发工具，使用趁手的设备。
> - 学会规划自己的时间。
>   - 定义好优先级。
>   - 最短作业优先。先把可以快速做完的事做完，有利于为后面复杂的工作争取更多的时间（老板只有在你有 Deliver 的时候才愿意给你更多的时间），另一方面，看到任务列表的减少会让你的心态更为积极。而反过来，你花太多的时间在长作业上，长作业通常很容易出现“意外情况”让你花更多的时间，但此时你发现还有很多别的事没有做，这会让你产生焦虑感，产生更多的压力，进而导致更慢的生产效率。
>   - 想清楚再做。
>   - 关注长期利益规划。要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。
> - 用好自己的时间。
>   - 将军赶路不追小兔。学会过滤掉与自己目标无关的事，不要让那些无关的事控制自己。能专注地把时间投入到一个有价值的事上是非常重要的。确定自己的目标，专注达到这个目标，而不是分心。
>     - 不要让别人来影响自己的心情，心情被影响了，你一下就会什么都不想干了。做自己心情的主人，不要让别人 hack 了你的心情。
>     - 知道哪些是自己可以控制的事，哪些是自己控制不了的事，在自己能控制的地方花时间。
>     - 知道哪些是更有效的路径，是花时间改变别人，还是花时间去寻找志同道合的人。不与不如自己的人争论，也不要尝试花时间去叫醒那些装睡的人，这些都是非常浪费时间的事。多花时间在有产出的事上，少花时间在说服别人的事上。
>   - 形成习惯。知道了时间管理方法后，更重要的是将这些时间管理方法养成习惯去执行。
>   - 形成正反馈，产生成就感。所谓正反馈，就是你有没有成就感，有没有再继续投入的的冲动。如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。
>   - 反思和举一反三。可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的“复盘”。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。
>
> ——《时间管理：如何利用好自己的时间？》



------



故障处理最佳实践

> - 故障发生时
>
>   - 快速定位故障源，并快速恢复故障。通常会有以下几种手段来恢复系统。
>
>     - 重启和限流。主要解决的是可用性的问题，不是功能性的问题。
>     - 回滚操作。一般来说是解决新代码的 bug，把代码回滚到之前的版本是快速的方式。
>     - 降级操作。需要挂一个停止服务的故障公告，主要是不要把事态扩大。
>     - 紧急更新。
>
>     出现故障时，最重要的不是 debug 故障，而是尽可能地减少故障的影响范围，并尽可能快地修复问题。
>
> - 故障前的准备工作
>
>   - 以用户功能为索引的服务和资源的全视图。这个全视图记录了前端用户操作界面和后端服务，以及服务使用到的硬件资源之间的关联关系。把后端的服务、服务的调用关系，以及服务使用到的资源都关联起来做成一个视图。这就好像一张地图，如果没有地图，我们只能像个无头苍蝇一样乱试了。（自动地图生成一般用APM式的系统。开源的可以看看zipkin、pinpoint skywalking zpkin）
>   - 为地图中的各个服务制定关键指标，以及一套运维流程和工具，包括应急方案。这就好像一个导航仪，能够告诉你怎么做。而没有导航仪，就没有章法，会导致混乱。
>   - 设定故障的等级。主要是为了确定该故障要牵扯进多大规模的人员来处理。
>   - 故障演练。
>   - 灰度发布系统。或是 A/B 测试（先发布某一个地区的，再发布其他地区的）
>
> ——《故障处理最佳实践：应对故障》



------



> 故障整改方法？
>
> - 优化故障获知和故障定位的时间。从故障发生到我们知道的时间是否可以优化得更短？定位故障的时间是否可以更短？有哪些地方可以做到自动化？
> - 优化故障的处理方式。故障处理时的判断和章法是否科学，是否正确？故障处理时的信息是否全透明？故障处理时人员是否安排得当？
> - 优化开发过程中的问题。Code Review 和测试中的问题和优化点。软件架构和设计是否可以更好？对于技术欠债或是相关的隐患问题是否被记录下来，是否有风险计划？
> - 优化团队能力。如何提高团队的技术能力？如何让团队有严谨的工程意识？
>
> 解决一个故障可以通过技术和管理两方面的方法。如果你喜欢技术，是个技术范，你就更多地用技术手段；如果你喜欢管理，那么你就会使用更多的管理手段。我是一个技术人员，我更愿意使用技术手段。
>
> 大多数情况下是因为这个公司的系统架构太过复杂和混乱，以至于你不可能在这样的环境下干干净净地解决所有的问题。所以，你要先做大扫除，简化掉现有的复杂和混乱。如果你要从根本上改善一个事，那么首先得把它简化了。原则：
>
> - 举一反三解决当下的故障。为自己赢得更多的时间。
> - 简化复杂、不合理的技术架构、流程和组织。你不可能在一个复杂的环境下根本地解决问题。
> - 全面改善和优化整个系统，包括组织。解决问题的根本方法是改善和调整整体结构。而只有简单优雅的东西才有被改善和优化的可能。
>
> ——《故障处理最佳实践：故障改进》



------



关于兴趣和投入

> - 一方面，兴趣是需要保持的。不能持久的兴趣，或是一时兴起的兴趣，都无法让人投入下去。
> - 另一方面，兴趣其实也是可以培养出来的。一个可以持久的兴趣，或是可以培养出来的兴趣，后面都有一个比较本质的东西，其实就是成就感，他是你坚持或者努力的最直接的正反馈。也就是说，兴趣只是开始，而能让人不断投入时间和精力的则是正反馈，是成就感。你需要找到让自己能够更有成就感的事情，兴趣总是可以培养的。
>
> ——《我们应该能够识别的表象和本质》



------



关于学习和工作

> 学好一项技术和是否找到与之相匹配的工作有关联，但它们之间并不是强关联的。但之所以，我们都觉得通过工作才让我们学习和成长得更快，主要有这些原因：
>
> - 工作能为我们带来相应的场景和实际的问题，而不是空泛的学习。带着问题去学习，带着场景去解决问题，的确是一种高效的学习方式。
> - 在工作当中，有同事和高手帮助。和他们的交互和讨论，可以让你更快地学习和成长。
>
> 本质上来说，并不是只有找到了相应的工作我们才可以学好一项技术，而是，我们在通过解决实际问题，在和他人讨论，获得高手帮助的环境中，才能更快更有效率地学习和成长。
>
> 有时候，在工作中你反而学不到东西，那是因为你找的这个工作能够提供的场景不够丰富，需要解决的实际问题太过简单，以及你的同事对你的帮助不大。这时，这个工作反而限制了你的学习和成长。
>
> - 找工作不只是找用这个技术的工作，更是要找场景，找实际问题，找团队。这些才是本质。一项技术很多公司都在用，然而，只有进入到有更多的场景、有挑战性的问题、有靠谱团队的公司，才对学习和成长更有帮助。
> - 不要完全把自己的学习寄希望于找一份工作，才会学得好。我给他的建议是，在一些开源社区内，有助于学习的场景会更多，要解决的实际问题也更多，同时你能接触到的牛人也更多。特别是一些有大量公司和几万、几十万甚至上百万的开发人员在贡献代码的项目，我认为可以让人成长很快。
>
> 总之，找到学习的方法，提升自己对新事物学习的能力，才是学习和成长的关键。
>
> ——《我们应该能够识别的表象和本质》



------



关于趋势和未来

> 技术的未来要去哪，主要是看这个世界的投入会到哪。基本上就是这个世界上的有钱有势的人把财富投到哪个领域，也就是这个世界的大公司或大国们的规划。
>
> ——《我们应该能够识别的表象和本质》



------



软件开发的工作模式

> - 以微服务或是 SOA（面向服务） 为架构的方式。一个大型软件会被拆分成若干个服务，那么，我们的代码应该也会跟着服务拆解成若干个代码仓库。这样一来，我们的每个代码仓库都会变小，于是我们的协同工作流程就会变简单。
> - 以 DevOps 为主的开发流程。DevOps 关注于 CI/CD，需要我们有自动化的集成测试和持续部署的工具。这样一来，我们的代码发布速度就会大大加快，每一次提交都能很快地被完整地集成测试，并很快地发布到生产线上。
>
> ——《Git协同工作流，你该怎么选？》



------



> 协同工作流的本质，并不是怎么玩好代码仓库的分支策略，而是玩好我们的软件架构和软件开发流程。
>
> 与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生产和运维流程上来，这才是真正简化协同工作流程的根本。
>
> ——《Git协同工作流，你该怎么选？》


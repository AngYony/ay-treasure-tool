# 程序员练级摘要



> 有修养的程序员才可能成长为真正的工程师和架构师，而没有修养的程序员只能沦为码农，这是码农和工程师的关键区分点。
>
> 几大从业方向：
>
> - 如果你对操作系统、文件系统、数据库、网络等比较感兴趣，那么可以考虑从事底层方面的工作。
> - 如果对分布式系统架构、微服务、DevOps、Cloud Native 等有热情，那么可以从事架构方面的工作。
> - 如果是对大数据、机器学习、人工智能等比较关注，那么数据领域可以成为你一展身手的地方。
> - 如果你对用户体验或者交互等更感兴趣，那么前端工程师也是个不错的选择。
> - 此外，安全开发、运维开发、嵌入式开发等几大方向中，也为你提供了丰富多彩的发展空间。
>
> 该如何选择应该完全遵从于你的本心，你更愿意在哪个领域里持续奋斗和学习。这个答案，在你的手中，在你的心中。这里我只想和你说两个观点：各种技术方向不是鱼和熊掌，是可以兼得的；很多技术是相通的，关键是你是学在表面还是深入本质。
>
> 软件设计是工程师非常重要的能力，这里描述了软件工程自发展以来的各种设计方法，这是从工程师通往架构师的必备技能。
>
> - 并不是理论和现实的差距大，而是你还没有找到相关的场景，来感受到那些学院派知识的强大威力。算法与数据结构、操作系统原理、编译原理、数据库原理、计算机原理……这些原理上的东西，是你想要成为一个专家必须要学的东西。如果你觉得这些理论上的东西无用，那么只能说明，你只不过在从事工人的工作，而不是工程师的工作。
> - 技术能力的瓶颈，以及技术太多学不过来，只不过是你为自己的能力不足或是懒惰找的借口罢了。技术的东西都是死的，这些死的知识只要努力就是可以学会的。只不过聪明的人花得时间少，笨点的人花得时间多点罢了。这其中的时间差距主要是由学习方法的不同，基础知识储备的不同决定的。只要你方法得当，多花点时间在基础知识上，会让你未来学习应用知识的时间大大缩短。以绝大多数人努力的程度，和为自己不努力找借口的程度为参考，只要你坚持正常的学习就可以超过大多数人了。
> - 这里没有学习技术的速成的方法，真正的牛人不是能够培训出来的，一切都是要靠你自己去努力和持续地付出。如果你觉得自己不是一个能坚持的人，也不是一个想努力的人，而是一个想找捷径的人，那么，这篇文章并不适合你。这篇文章中的成长路径是需要思考、精力和相关的经验的，这都需要时间，而且是不短的时间。你先问问自己有没有花十年磨一剑的决心，如果没有，那这篇文章对你没有任何作用。
>
> 学习建议：
>
> - 一定要坚持，要保持长时间学习，甚至终生学习的态度。
> - 一定要动手，不管例子多么简单，建议至少自己动手敲一遍看看是否理解了里头的细枝末节。
> - 一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。
> - ==不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累，会在未来至少 10 年通用==。
> - 回顾一下历史，看看历史时间线上技术的发展，你才能明白明天会是什么样的。
>
> ——《程序员练级攻略：开篇词》





## 第一阶段：零基础启蒙

零基础启蒙，指的是完全没有任何编程经验的，甚至不懂什么是编程的。

第一部分：体会什么是编程，入门教程资源有：

- 《与孩子一起学编程》（这本书以 Python 语言教你如何写程序，是一本老少咸宜的编程书。其中会教你编一些小游戏，还会和你讲基本的编程知识，相当不错。）
- 两个在线编程入门的网站：[Codecademy: Learn Python](https://www.codecademy.com/learn) 和 [People Can Program](https://www.peoplecanprogram.com/) ，你也可以在这两个网站上学习 Python，只不过是英文的。然后，你可以到 [CodeAbbey](http://www.codeabbey.com/index/task_list) 上去做一些在线编程的小练习。

第二部分：使用编程做一些实际有用的的东西，产生正反馈，目的是培养编程的兴趣。

[MDN 的 Web 开发入门](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web) ，MDN 全称是 Mozilla Developer Network，你可以认为是 Web 方面的官方技术网站。这个教程会带着你建立一个网站。



## 第二阶段：编程入门

这一阶段，使用Python和JavaScript作为入门语言。

Python入门资源：

- 《Python 编程：从入门到实践》（优先）
- 《Python编程快速上手》

JavaScript入门资源：

- [MDN JavaScript 教程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)，你可以认为这是最权威的 JavaScript 官方教程了，从初级到中级再到高级。
- [W3School JavaScript 教程](https://www.w3school.com.cn/js/index.asp)，这个教程比较偏 Web 方面的编程。
- [JavaScript全栈教程（廖雪峰）](https://www.liaoxuefeng.com/wiki/1022910821149312)，这是廖雪峰的一个比较偏应用的教程，也是偏 Web 方面的编程，同时包括涉及后端的 Node.js 方面的教程。

Linux入门：

- W3CSchool 上的在线教程 [Linux 教程](https://www.w3cschool.cn/linux/)。

编程工具：[Visual Studio Code](https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/)

Web编程入门：

- 前端基础。[CSS 文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 和 [HTML 文档](https://developer.mozilla.org/zh-CN/docs/Web/HTML)，注意：文档很大，你要学习的并不是所有的东西，而是了解 CSS 和 HTML 是怎么相互作用来展示数据的，然后，不用记忆文档中的内容，==这两个文档是用来查找知识的==。
- 后端基础。直接使用Python即可。

这一阶段的学习要点是：

- 学习 HTML 基本语法。
- 学习 CSS 如何选中 HTML 元素并应用一些基本样式。
- 学会用 Firefox + Firebug 或 Chrome 查看你觉得很炫的网页结构，并动态修改。
- 在一台 Linux 机器上配置 LEMP - Ubuntu/Nginx/PHP/MySQL 这个环境。
- 能够使用后端语言，实现与前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。
- 能够连接远程数据库MySQL（MySQL 和 SQL 现学现用即可）。

注意：==这一阶段对于这些语言你也不用学得特别精通，感觉一下这几个不同的语言就可以了，然后知道相关的文档和知识在哪里，这样有助于你查阅相应的知识点。==

**无论你做什么事，你都会面对各式各样的困难，这对每个人来说都是一样的，而只有兴趣、热情和成就感才能让你不畏惧这些困难。**



## 第三阶段：正式入门

第一部分：编程技能

- [The Key To Accelerating Your Coding Skills](http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/)， 这篇文章会告诉你如何有效地快速提高自己的编程能力。
- 《代码大全》
- 《Java核心技术·卷 I》（优先）
- 《Spring实战》
- 《Spring Boot实战》（优先Spring Boot）
- 《鸟哥的Linux私房菜》（这本书有很多比较专业的知识，你可能会看不懂，没关系，就暂时略过就好了。这本书的确并不适合初学者，你能看多少就看多少）
- [HTTP 的文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)。需要知道 HTTP 协议的几个关键点：1）HTTP 头，2）HTTP 的请求方法，3）HTTP 的返回码。还有，HTTP 的 Cookie、缓存、会话，以及链接管理，等等。对于 HTTP 协议，你不需要知道所有的东西，你只需要了解这个协议的最关键的那些东西就好了。
- 《MySQL 必知必会》
- [关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）](http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html)

第二部分：编程工具

- Intellij IDEA（[教程](https://www.gitbook.com/book/dancon/intellij-idea/details)）
- Visual  Studio Code （[教程](https://legacy.gitbook.com/book/jeasonstudio/vscode-cn-doc/details)）
- 《[Pro Git 第二版](https://git-scm.com/book/zh/v2/)》（如果你觉得 Pro Git 比较枯燥的话，备选[猴子都能懂的 Git 入门](https://backlog.com/git-tutorial/cn/)）
- GitHub，比如：这篇[GitHub and Git 图文教程](https://github.com/JiapengLi/GitTutorial) 或是这篇[Git 图文教程及详解](https://www.jianshu.com/p/1b65ed31da97)）。
- 调试前端程序。[超完整的 Chrome 浏览器客户端调试大全](http://www.igeekbar.com/igeekbar/post/156.htm)。
- 数据库设计工具。

**因为你并不知道你未来会有多大的可能性，也不知道你会成为什么样的人，所以为什么不再更努力一把呢？**



## 第四阶段：程序员修养

第一部分：编程建议

《[97 Things Every Programmer Should Know](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/index.html)》97 个非常不错的编程方面的建议。

第二部分：==英文能力==

- 坚持 Google 英文关键词，而不是在 Google 里搜中文。
- 在 GitHub 上只用英文。用英文写代码注释，写 Code Commit 信息，用英文写 Issue 和 Pull Request，以及用英文写 Wiki。
- [剑桥英语词典](https://dictionary.cambridge.org/) 或是 [Dictionary.com](https://www.dictionary.com/)
- 坚持用英文的教材而不是中文的。比如：[BBC 的 Learning English](http://www.bbc.co.uk/learningenglish/) ，或是到一些 ESL 网站上看看，如 [ESL: English as a Second Language](https://www.rong-chang.com/) 上有一些课程。
- 花钱参加一些线上的英文课程，用视频和老外练习。

第三部分：提问题的能力

- [How To Ask Questions The Smart Way](http://www.catb.org/~esr/faqs/smart-questions.html)
- [X-Y Problem](http://xyproblem.info/)或《[X-Y 问题](https://coolshell.cn/articles/10804.html)》
- [FAQ for StackExchange Site](https://meta.stackexchange.com/questions/7931/faq-for-stack-exchange-sites)

第四部分：写代码的修养

- 《代码大全》
- 《重构：改善既有代码的设计》
- 《==修改代码的艺术==》（优先，这本书是继《重构》之后探讨修改代码技术的又一里程碑式的著作，而且从涵盖面和深度上都超过了前两部经典（《代码大全》和《重构》））
- 《代码整洁之道》
- 《程序员的职业素养》

第五部分：Code Review能力

- [Code Review Best Practices](https://medium.com/@palantir/code-review-best-practices-19e02780015f)
- [How Google Does Code Review](https://dzone.com/articles/how-google-does-code-review)
- [LinkedIn’s Tips for Highly Effective Code Review](https://thenewstack.io/linkedin-code-review/)

第六部分：Unit Test能力

- Java中，写 Unit Test 的框架一般来说都是从 JUnit 衍生出来的，比如 CppUnit 之类的。学习 JUnit 使用的最好方式就是到其官网上看[JUnit User Guide](https://junit.org/junit5/docs/current/user-guide/)（Junit[中文版](https://sjyuan.club/junit5/user-guide-cn/)）。
- [You Still Don’t Know How to Do Unit Testing](https://stackify.com/unit-testing-basics-best-practices/)
- [Unit Testing Best Practices: JUnit Reference Guide](https://dzone.com/articles/unit-testing-best-practices)
- [JUnit Best Practices](http://www.kyleblaney.com/junit-best-practices/)

第七部分：安全防范

- [OWASP - Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)。
- 中文版《[OWASP Top 10 2017 PDF 中文版](https://www.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf)》。
- [伯克立大学的 Secure Coding Practice Guidelines](https://security.berkeley.edu/secure-coding-practice-guidelines)。
- [卡内基梅隆大学的 SEI CERT Coding Standards](https://wiki.sei.cmu.edu/confluence/display/seccode/SEI+CERT+Coding+Standards)。
- 《[Hardening Your HTTP Security Headers](https://www.keycdn.com/blog/http-security-headers)》。
- 防御性编程，英文叫Defensive Programming，它是为了保证对程序的不可预见的使用，不会造成程序功能上的损坏。它可以被看作是为了减少或消除墨菲定律效力的想法。防御式编程主要用于可能被滥用，恶作剧或无意地造成灾难性影响的程序上。下面是一些文章。[The Art of Defensive Programming](https://medium.com/web-engineering-vox/the-art-of-defensive-programming-6789a9743ed4)。当然，也别太过渡了，这篇文章可以看看，[Overly defensive programming](https://medium.com/@cvitullo/overly-defensive-programming-e7a1b3d234c2)。

第八部分：软件测试、上线规范和运维

- 《完美软件：对软件测试的各种幻想》
- 《Google 软件测试之道》
- 上线前的检查
  - [Server Side checklist](https://github.com/mtdvio/going-to-production/blob/master/serverside-checklist.md)
  - [Single Page App Checklist](https://github.com/mtdvio/going-to-production/blob/master/spa-checklist.md)
- 运维：《[Monitoring 101](https://www.datadoghq.com/blog/monitoring-101-collecting-data/)》

第九部分：编程规范

- Go
  - [Effective Go](https://golang.org/doc/effective_go.html)，Go 语言的最佳实践只需要看这篇官方文档就够了。
- Java
  - [Code Conventions for the Java™ Programming Language](https://www.oracle.com/technetwork/java/codeconvtoc-136057.html) ，Java 官方的编程规范。
  - [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)，Google 的 Java 编码规范。
- JavaScript
  - [JavaScript The Right Way](http://jstherightway.org/)，一个相对比较容读的 JavaScript 编程规范，其中不但有代码规范，还有设计模式，测试工具，编程框架，游戏引擎。
  - [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)，Google 公司的 JavaScript 的编码规范，一个非常大而全的编程规范。
  - [jQuery Core Style Guide](http://contribute.jquery.org/style-guide/js/)，jQuery 的代码规范。
  - [JavaScript Clean Code](https://github.com/ryanmcdermott/clean-code-javascript)，前面推荐过的《代码整洁之道》一书中的 JavaScript 的实践 。
  - 其它相对比较简单的 JavaScript 编程规范：
    - [JavaScript Style Guides And Beautifiers](https://addyosmani.com/blog/javascript-style-guides-and-beautifiers/)，这是一篇推荐 JavaScript 编程规范的文章。
    - [JavaScript Style Guide and Coding Conventions](https://www.w3schools.com/js/js_conventions.asp)，这是 W3Schools 的 JavaScript。
    - [Code Conventions for the JavaScript](http://crockford.com/javascript/code.html)
- Python
  - [Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/)，Python 官方的编程码规范。
  - [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)，Google 公司的 Python 编码规范。
  - [The Hitchhiker’s Guide to Python](http://docs.python-guide.org/en/latest/)，这不只是 Python 的编程规范，还是 Python 资源的集散地，强烈推荐。
- Rust
  - [Rust Style Guide](https://github.com/rust-lang-nursery/fmt-rfcs/blob/master/guide/guide.md)
  - [Rust Guidelines](http://aturon.github.io/) 开源社区里最好的 Rust 编程规范。
- Shell
  - [Google Shell Style Guide](https://google.github.io/styleguide/shell.xml)，Google 的 Shell 脚本编程规范。
- [Mozilla Coding Style Guide](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style)，其中包括 C、C++、Java、Python、JavaScript、Makefile 和 SVG 等编程规范。
- 前端开发相关
  - [CSS Guidelines](https://cssguidelin.es/)
  - [Frontend Guidelines](https://github.com/bendc/frontend-guidelines)，一些和 HTML、CSS、JavaScript 相关的最佳实践。
  - [Sass Guidelines](https://sass-guidelin.es/)，Sass 作为 CSS 的补充，其要让 CSS 变得更容易扩展。然而，也变得更灵活，这意味着可以被更容易滥用。这里这篇 " 富有主见 " 的规范值得你一读。
  - Less Guidelines
    - [LESS Coding Guidelines](https://github.com/odoo/odoo/wiki/LESS-coding-guidelines)
    - [LESS coding standard](https://devdocs.magento.com/guides/v2.3/coding-standards/code-standard-less.html)
  - [HTML Style Guide](https://github.com/marcobiedermann/html-style-guide)，一个教你如何写出性能更高，结构更好，容易编程和扩展的 HTML 的规范。
  - [HTML + CSS Code Guide](https://codeguide.co/)，如何写出比较灵活、耐用、可持续改进的 HTML 和 CSS 的规范。
  - [Google HTML/CSS Style Guide](https://google.github.io/styleguide/htmlcssguide.html)，Google 的 HTML/CSS 的编程规范。
  - [Guidelines for Responsive Web Design](https://www.smashingmagazine.com/2011/01/guidelines-for-responsive-web-design/) ，响应式 Web 设计的规范和最佳实践。
  - [U.S. Web Design Standards](https://standards.usa.gov/)，这是美国政府网端要求的一些 UI 交互可视化的一些规范。
- 前端开发的各种注意事项列表
  - [Front-End Checklist](https://github.com/thedaviddias/Front-End-Checklist) ，一个前端开发的 Checklist，其中包括 HTML、CSS 和 JavaScript，还和图片、字体、SEO、性能相关，还包括关一些和安全相关的事项，这个列表真的是太好了。
- API相关的规范
  - [HAL](http://stateless.co/hal_specification.html)，一个简单的 API 规范教程。
  - [Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines)，微软软的 Rest API 规范。
  - [API Design Guide](http://apiguide.readthedocs.io/en/latest/)。
  - [RESTful API Designing guidelines - The best practices](https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9)。
  - [JSON API - Recommendations](http://jsonapi.org/recommendations)，JSON 相关的 API 的一些推荐实践。
  - [API Security Checklist ](https://github.com/shieldfy/API-Security-Checklist)，API 的安全问题的检查列表。
- 开发工具相关
  - Markdown 相关
    - [Google Markdown Style Guide](https://github.com/google/styleguide/blob/gh-pages/docguide/style.md)。
    - [Markdown Style Guide](https://cirosantilli.com/markdown-style-guide/)。
  - JSON
    - [Google JSON Style Guide](https://google.github.io/styleguide/jsoncstyleguide.xml)。
  - Git 相关
    - [Git Style Guide](https://github.com/agis/git-style-guide)。
    - [Few Rules from Git Documentation](https://github.com/git/git/blob/master/Documentation/CodingGuidelines)。
  - 正则表达式相关
    - [RegexHQ](https://github.com/regexhq)。
    - [Learn regex the easy way](https://github.com/ziishaned/learn-regex)。



**有修养的程序员才可能成长为真正的工程师和架构师，而没有修养的程序员只能沦为码农。**



## 第五阶段：进入专业的编程领域

第一部分：编程语言

**编程语言不要取舍，要排优先级**

- C / C++
  - 《[C 程序设计语言](https://book.douban.com/subject/1139336/)》注意，这本书是 C 语言原作者写的，其 C 语言的标准不是我们平时常说的 ANSI 标准，而是原作者的标准，又被叫作 K&R C。对了，千万不要看谭浩强的 C 语言的书。各种误导，我大学时就是用这本书学的 C，后来工作时被坑得不行。
  - 《[C 语言程序设计现代方法](https://book.douban.com/subject/2280547/)》
  - 《[C 陷阱与缺陷](https://book.douban.com/subject/2778632/)》
  - 《[C++ Primer 中文版](https://book.douban.com/subject/25708312/)》
  - 《[Effective C++](https://book.douban.com/subject/5387403/)》和《[More Effective C++](https://book.douban.com/subject/5908727/)》
  - 《[深度探索 C++ 对象模型](https://book.douban.com/subject/10427315/) 》（难度极大）
  - [C++ FAQ](http://www.stroustrup.com/bs_faq.html)，[中文版](http://www.stroustrup.com/bsfaqcn.html)
- ==Java==
  - 入门
    - 《[Java 核心技术：卷 1 基础知识](https://book.douban.com/subject/26880667/)》（优先）
    - 《[Spring Boot 实战](https://book.douban.com/subject/26857423/)》（Spring家族优先选Spring Boot）
    - 《[Spring 实战](https://book.douban.com/subject/26767354/)》
  - 进阶
    - 《[Effective Java](https://book.douban.com/subject/27047716/)》（第三版）
    - [Google Guava 库](https://github.com/google/guava)，这个库不但是 JDK 的升级库，其中有如：集合（collections）、缓存（caching）、原生类型支持（primitives support）、并发库（concurrency libraries）、通用注解（common annotations）、字符串处理（string processing）、I/O 等库，其还是 Effective Java 这本书中的那些经验的实践代表。
    - 《[Java 并发编程实战](https://book.douban.com/subject/10484692/)》
    - 《[Java 性能权威指南](https://book.douban.com/subject/26740520/)》
    - 《[深入理解 Java 虚拟机](https://book.douban.com/subject/24722612/)》
    - 《[Java 编程思想](https://book.douban.com/subject/2130190/)》
    - 《[精通 Spring 4.x](https://book.douban.com/subject/26952826/)》
    - 《[设计模式](https://book.douban.com/subject/1052241/)》或《[Head First 设计模式](https://book.douban.com/subject/2243615/)》或《大话设计模式》
- go
  - 入门
    - [Go by Example](https://gobyexample.com/)
    - [Go 101](https://go101.org/article/101.html)
    - “[GO 语言简介（上）- 语法](https://coolshell.cn/articles/8460.html)” 和 “[GO 语言简介（下）- 特性](https://coolshell.cn/articles/8489.html)”）。
    - 《[The Go Programming Language](https://book.douban.com/subject/26337545/)》中译本《Go 程序设计语言》
  - 进阶
    - [Effective Go](https://golang.org/doc/effective_go.html)
    - [Go 精华文章列表](https://github.com/golang/go/wiki/Articles)
    - [Go 相关博客列表](https://github.com/golang/go/wiki/Blogs)
    - [Go Talks](https://github.com/golang/go/wiki/GoTalks)
    - [Awesome Go](https://github.com/avelino/awesome-go)

Java语言让你不用关注底层，而关注业务和架构，C语言让你关注底层原理，Go语言介于C和Java之间，掌握多门语言会让你对他们有比较。他们各有各的适用场景。

第二部分：理论学科

- 数据结构与算法
- 计算机原理
- 网络模型

第三部分：系统知识

- Unix/Linux
- TCP/IP
- C10K挑战



## 第六阶段：理论学科

第一部分：数据结构和算法

- 《[算法](https://book.douban.com/subject/10432347/)》
- 《[算法图解](https://book.douban.com/subject/26979890/)》
- 《[算法导论](https://book.douban.com/subject/20432061/)》
- 《[编程珠玑](https://book.douban.com/subject/3227098/)》
- 《[数据结构与算法分析](https://book.douban.com/subject/1139426/)》
- LeetCode
- [List of Algorithms](https://www.wikiwand.com/en/List_of_algorithms)
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

第二部分：计算机系统知识

- ==《[深入理解计算机系统](https://book.douban.com/subject/5333562/)》==（这本书是程序员必读的一本书！）
- 《[Unix 高级环境编程](https://book.douban.com/subject/1788421/)》
- 《Unix 网络编程》 [第 1 卷 套接口 API](https://book.douban.com/subject/1500149/) 、[第 2 卷 进程间通信 ](https://book.douban.com/subject/4118577/)
- 《[Linux/Unix 系统编程手册](https://book.douban.com/subject/25809330/)》
- 《[Linux 系统编程](https://book.douban.com/subject/25828773/)》
- 《[TCP/IP 详解 卷 I 协议](https://book.douban.com/subject/1088054/)》
- 《[Linux C 编程一站式学习](https://book.douban.com/subject/4141733/)》（适合入门）
- 《[TCP/IP 网络编程](https://book.douban.com/subject/25911735/)》（适合基础）
- 《[图解 TCP/IP](https://book.douban.com/subject/24737674/)》（适合快速入门）
- 《[The TCP/IP Guide](http://www.tcpipguide.com/free/index.htm)》
- 《[Wireshark 数据包分析实战](https://book.douban.com/subject/21691692/)》
- 《[Wireshark网络分析就这么简单](https://book.douban.com/subject/26268767/)》
- 《[wireshark网络分析的艺术](https://book.douban.com/subject/26710788/)》
- TCP其他资料
  - [Let’s code a TCP/IP stack, 1: Ethernet & ARP](https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/)
  - [Let’s code a TCP/IP stack, 2: IPv4 & ICMPv4](https://www.saminiir.com/lets-code-tcp-ip-stack-2-ipv4-icmpv4/)
  - [Let’s code a TCP/IP stack, 3: TCP Basics & Handshake](https://www.saminiir.com/lets-code-tcp-ip-stack-3-tcp-handshake/)
  - [Let’s code a TCP/IP stack, 4: TCP Data Flow & Socket API](https://www.saminiir.com/lets-code-tcp-ip-stack-4-tcp-data-flow-socket-api/)
  - [Let’s code a TCP/IP stack, 5: TCP Retransmission](https://www.saminiir.com/lets-code-tcp-ip-stack-5-tcp-retransmission/)
- C10K问题
  - C10K 问题本质上是操作系统处理大并发请求的问题。对于 Web 时代的操作系统而言，对于客户端过来的大量的并发请求，需要创建相应的服务进程或线程。这些进程或线程多了，导致数据拷贝频繁（缓存 I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程 / 线程上下文切换消耗大，从而导致资源被耗尽而崩溃。这就是 C10K 问题的本质。
  - [C10K Problem](http://www.kegel.com/c10k.html) （[中文翻译版](https://www.oschina.net/translate/c10k)）
  - [The Secret To 10 Million Concurrent Connections -The Kernel Is The Problem, Not The Solution](http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html)

第三部分：其他理论基础知识

《[数据库系统概念](https://book.douban.com/subject/1929984/)》（数据库）

《[现代操作系统](https://book.douban.com/subject/3852290/)》（操作系统）

《[计算机网络](https://book.douban.com/subject/1391207/)》（网络模型）

《[计算机程序的构造和解释](https://book.douban.com/subject/1148282/)》（计算机原理）

《[编译原理](https://book.douban.com/subject/3296317/)》（可跳过）（编译方面，龙书比较偏理论、一般原理。虎书主要是编译优化，鲸书是设计、实现）

**这些理论知识可以说是计算机科学这门学科最精华的知识了，认真学习，理解其背后的逻辑和思维方式，会让你受益匪浅。**

**如果经历过这些比较枯燥的理论知识，而且你还能有热情和成就感，那么我要恭喜你了。因为你已经超过了绝大多数人，而且还是排在上游的比较抢手的程序员了。我相信你至少可以找到年薪 50 万以上的工作了。**



## 第七阶段：软件设计

如果你想成为一名优秀的程序员，软件设计定是你的必修课。

第一部分：编程范式

学习编程范式可以让你明白编程的本质和各种语言的编程方式。

- 《编程范式游记》系列
- [Wikipedia: Programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm)（维基百科上的编程范式）
- [Six programming paradigms that will change how you think about coding](https://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/)，中文翻译版为 [六个编程范型将改变你对编程的看法](https://my.oschina.net/editorial-story/blog/890965)。这篇文章讲了默认支持并发（Concurrent by default）、依赖类型（Dependent types）、连接性语言（Concatenative languages）、声明式编程（Declarative programming）、符号式编程（Symbolic programming）、基于知识的编程（Knowledge-based programming）等六种不太常见的编程范式，并结合了一些你没怎么听说过的语言来分别进行讲述。
- [Programming Paradigms for Dummies: What Every Programmer Should Know](https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf)这篇文章里分析了编程语言在历史上的演进，有哪些典型的、值得研究的案例，里面体现了哪些值得学习的范式。
- [斯坦福大学公开课：编程范式](http://open.163.com/newview/movie/courseintro?newurl=/special/opencourse/paradigms.html)，这是一门比较基础且很详细的课程，适合学习编程语言的初学者。

第二部分：软件设计的相关原则

- [Don’t Repeat Yourself (DRY)]([http://en.wikipedia.org/wiki/Don%27t_repeat_yourself](http://en.wikipedia.org/wiki/Don't_repeat_yourself))：DRY 是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当在两个或多个地方发现一些相似代码的时候，我们需要把它们的共性抽象出来形成一个唯一的新方法，并且改变现有地方的代码让它们以一些合适的参数调用这个新的方法。
- [Keep It Simple, Stupid(KISS)](http://en.wikipedia.org/wiki/KISS_principle)：KISS 原则在设计上可能最被推崇，在家装设计、界面设计和操作设计上，复杂的东西越来越被众人所鄙视了，而简单的东西越来越被人所认可。
- Program to an interface, not an implementation，这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。还有一条原则叫 Composition over inheritance（喜欢组合而不是继承），这两条是那 23 个经典设计模式中的设计原则。
- [You Ain’t Gonna Need It (YAGNI)]([http://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It](http://en.wikipedia.org/wiki/You_Ain't_Gonna_Need_It))：这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后你需要更多功能时，可以再进行添加。如无必要，勿增复杂性。
- [Law of Demeter](http://en.wikipedia.org/wiki/Principle_of_Least_Knowledge)，迪米特法则 (Law of Demeter)，又称“最少知识原则”（Principle of Least Knowledge）。在《程序员修炼之道》中讲 LoD 的那一章将其叫作“解耦合与迪米特法则”。关于迪米特法则有一些很形象的比喻：1) 如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？2) 如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？和狗的四肢说话？让店员自己从钱包里拿钱？这听起来有点儿荒唐，不过在我们的代码里这几乎是见怪不怪的事情了。对于 LoD，正式的表述如下：对于对象 ‘O’ 中一个方法’M’，M 应该只能够访问以下对象中的方法：
  - 对象 O；
  - 与 O 直接相关的 Component Object；
  - 由方法 M 创建或者实例化的对象；
  - 作为方法 M 的参数的对象。
- [面向对象的 S.O.L.I.D 原则](http://en.wikipedia.org/wiki/Solid_(object-oriented_design))：
  - SRP（Single Responsibility Principle）- 职责单一原则。关于单一职责原则，其核心的思想是：一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。单一职责，通常意味着单一的功能，因此不要为一个模块实现过多的功能点，以保证实体只有一个引起它变化的原因。
  - OCP（Open/Closed Principle）- 开闭原则。关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。
  - LSP（Liskov substitution principle）- 里氏代换原则。软件工程大师罗伯特·马丁（Robert C. Martin）把里氏代换原则最终简化为一句话：“Subtypes must be substitutable for their base types”。也就是，子类必须能够替换成它们的基类。即子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现 if/else 之类对子类类型进行判断的条件。里氏替换原则 LSP 是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。
  - ISP（Interface Segregation Principle ）- 接口隔离原则。接口隔离原则的意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。
  - DIP（Dependency Inversion Principle）- 依赖倒置原则。高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。
- [CCP（Common Closure Principle）](http://wiki.c2.com/?CommonClosurePrinciple) - 共同封闭原则，一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，那么我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP 原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果两个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。CCP 延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。
- [CRP（Common Reuse Principle）](http://wiki.c2.com/?CommonReusePrinciple)- 共同重用原则 ，包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该组合在一起。CRP 原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。CCP 则让系统的维护者受益。CCP 让包尽可能大（CCP 原则加入功能相关的类），CRP 则让包尽可能小（CRP 原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。
- [好莱坞原则 - Hollywood Principle](http://en.wikipedia.org/wiki/Hollywood_Principle) ，好莱坞原则就是一句话——“don’t call us, we’ll call you.”。意思是，好莱坞的经纪人不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。简单来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：1) 不创建对象，而是描述创建对象的方式。2）在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。好莱坞原则就是IoC（Inversion of Control） 或DI（Dependency Injection）的基础原则。
- [高内聚， 低耦合 & - High Cohesion & Low/Loose coupling](http://en.wikipedia.org/wiki/Coupling_(computer_science))，把模块间的耦合降到最低，而努力让一个模块做到精益求精。内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。
- [CoC（Convention over Configuration）- 惯例优于配置原则](http://en.wikipedia.org/wiki/Convention_over_Configuration) ，简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate 的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不 convention 的信息即可，从而减少了大量 convention 而又不得不花时间和精力啰里啰嗦的东东。
- SoC (Separation of Concerns) - 关注点分离 ，SoC 是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。
  - 标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。
  - 不断地把程序的某些部分抽象并包装起来，也是实现关注点分离的好方法。一旦一个函数被抽象出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的。同样的，一旦一个类被抽象并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。诸如组件、分层、面向服务等这些概念都是在不同的层次上做抽象和包装，以使得使用者不用关心它的内部实现细节。
- [DbC（Design by Contract）- 契约式设计](http://en.wikipedia.org/wiki/Design_by_contract) ，DbC 的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。如果在程序设计中一个模块提供了某种功能，那么它要：
  - 期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。
  - 保证退出时给出特定的属性：这就是模块的后验条件（供应商的义务，显然也是客户的权利）。
  - 在进入时假定，并在退出时保持一些特定的属性：不变式。
- [ADP（Acyclic Dependencies Principle）- 无环依赖原则 ](http://wiki.c2.com/?AcyclicDependenciesPrinciple)，包（或服务）之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有两种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果 A、B、C 形成环路依赖，那么把这些共同类抽出来放在一个新的包 D 里。这样就把 C 依赖 A 变成了 C 依赖 D 以及 A 依赖 D，从而打破了循环依赖关系。第二种方法是使用 DIP（依赖倒置原则）和 ISP（接口分隔原则）设计原则。无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。

第三部分：软件设计书籍

- 《[领域驱动设计](https://book.douban.com/subject/26819666/)》/《实现领域驱动设计》
- 《[UNIX 编程艺术](https://book.douban.com/subject/1467587/)》
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)、《[Clean Architecture](https://book.douban.com/subject/26915970/)》、《[Clean Code](https://book.douban.com/subject/5442024/)》（代码整洁之道）、《[The Clean Coder](https://book.douban.com/subject/11614538/)》（程序员的职业素养）
- [The Twelve-Factor App](https://12factor.net/)（[中译版](https://12factor.net/zh_cn/)）如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS），12-Factor 为构建 SaaS 应用提供了方法论，这也是架构师必读的文章。
- [Avoid Over Engineering](https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8)，有时候，我们会过渡设计我们的系统，过度设计会把我们带到另外一个复杂度上，所以，我们需要一些工程上的平衡。这篇文章是一篇非常不错地告诉你什么是过度设计的文章。
- [Instagram Engineering’s 3 rules to a scalable cloud application architecture](https://medium.com/@DataStax/instagram-engineerings-3-rules-to-a-scalable-cloud-application-architecture-c44afed31406) ，Instagram 工程的三个黄金法则：1）使用稳定可靠的技术（迎接新的技术）；2）不要重新发明轮子；3）Keep it very simple。我觉得这三条很不错。其实，Amazon 也有两条工程法则，一个是自动化，一个是简化。
- [How To Design A Good API and Why it Matters - Joshua Bloch](https://www.infoq.com/presentations/effective-api-design) ，Google 的一个分享，关于如何设计好一个 API。
- 关于 Restful API 的设计：
  - [Best Practices for Designing a Pragmatic RESTful API](https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api)
  - [Ideal REST API design](https://betimdrenica.wordpress.com/2015/03/09/ideal-rest-api-design/)
  - [HTTP API Design Guide](https://github.com/interagent/http-api-design)
  - [Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md)
  - [IBM Watson REST API Guidelines](https://github.com/watson-developer-cloud/api-guidelines)
  - [Zalando RESTful API and Event Scheme Guidelines](https://opensource.zalando.com/restful-api-guidelines/)
- [The Problem With Logging](https://blog.codinghorror.com/the-problem-with-logging/) ，一篇关于程序打日志的短文，可以让你知道一些可能以往不知道的打日志需要注意的问题。
- [Concurrent Programming for Scalable Web Architectures ](http://berb.github.io/diploma-thesis/community/index.html)，这是一本在线的免费书，教你如何架构一个可扩展的高性能的网站。其中谈到了一些不错的设计方法和知识。

**要学好这些软件开发和设计的方法，你真的需要磨练和苦行，反复咀嚼，反复推敲，在实践和理论中螺旋式地学习，才能真正掌握。 所以，你需要有足够的耐心和恒心。**



## 第八阶段：高手成长部分

### 第一部分：系统底层相关，Linux系统、内存和网络

#### Linux 系统，内核、原理

- [Red Hat Enterprise Linux 文档](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/?version=7)
- [Linux Insides](https://github.com/0xAX/linux-insides)（GitHub 上的一个开源电子书，讲述了 Linux 内核是怎样启动、初始化以及进行管理的）
- [LWN’s kernel page](http://lwn.net/Kernel/Index/)（讲述Linux 内核的）
- [Learn Linux Kernel from Android Perspective](http://learnlinuxconcepts.blogspot.com/2014/10/this-blog-is-to-help-those-students-and.html)（从 Android 的角度来学习 Linux 内核）
- [Linux Kernel Doc](https://www.kernel.org/doc/)（Linux 的内核文档）
- [Kernel Planet](http://planet.kernel.org/)（Linux 内核开发者的 Blog，有很多很不错的文章和想法）
- [Linux Performance](http://www.brendangregg.com/linuxperf.html)（这个网站上提供了和 Linux 系统性能相关的各种工具和文章收集，非常不错。）
- [Optimizing web servers for high throughput and low latency](https://blogs.dropbox.com/tech/2017/09/optimizing-web-servers-for-high-throughput-and-low-latency/)（这是一篇非常底层的系统调优的文章，来自 DropBox，从中你可以学到很多底层的性能调优的经验和知识。）

#### Linux内存管理

- 《[What every programmer should know about memory](http://futuretech.blinkenlights.nl/misc/cpumemory.pdf)》,[第一章网页版](https://lwn.net/Articles/250967/)（文章的底部可以链接到下一章）（[中译版](https://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1)）

- 论文：[Memory Barriers: a Hardware View for Software Hackers](https://irl.cs.ucla.edu/~yingdi/web/paperreading/whymb.2010.06.07c.pdf)，内存的读写屏障是线程并发访问共享的内存数据时，从程序本身、编译器到 CPU 都必须遵循的一个规范。有了这个规范，才能保证访问共享的内存数据时，一个线程对该数据的更新能被另一个线程以正确的顺序感知到。在 SMP（对称多处理）这种类型的多处理器系统（包括多核系统）上，这种读写屏障还包含了复杂的缓存一致性策略。这篇文章做了详细解释。

- 论文：[A Tutorial Introduction to the ARM and POWER Relaxed Memory Models](https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf)，对 ARM 和 POWER 的宽松内存模型的一个教程式的简介。本篇文章的焦点是 ARM 和 POWER 体系结构下多处理器系统内存并发访问一致性的设计思路和使用方法。与支持较强的 TSO 模型的 x86 体系结构不同，ARM 和 POWER 这两种体系结构出于对功耗和性能的考虑，使用了一种更为宽松的内存模型。本文详细讨论了 ARM 和 POWER 的模型。

- 论文：[x86-TSO: A Rigorous and Usable Programmer’s Model for x86 Multiprocessors](https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf)，介绍 x86 的多处理器内存并发访问的一致性模型 TSO。

- 内存管理方面的 lib 库：

  - [ptmalloc](http://www.malloc.de/en/) 是 glibc 的内存分配管理。
  - [tcmalloc](https://github.com/gperftools/gperftools) 是 Google 的内存分配管理模块，全称是 Thread-Caching malloc，基本上来说比 glibc 的 ptmalloc 快两倍以上。
  - [jemalloc](http://jemalloc.net/) 是 BSD 提供的内存分配管理。其论文为 [A Scalable Concurrent malloc(3) Implementation for FreeBSD](https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf)，这是一个可以并行处理的内存分配管理器。

  就目前而言，BSD 的 jemalloc 有很大的影响力。

- [ptmalloc，tcmalloc 和 jemalloc 内存分配策略研究](https://owent.net/2013/867.html)

- [内存优化总结：ptmalloc、tcmalloc 和 jemalloc](http://www.cnhalo.net/2016/06/13/memory-optimize/)

- [Scalable memory allocation using jemalloc](https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919)

- [Decreasing RAM Usage by 40% Using jemalloc with Python & Celery](https://zapier.com/engineering/celery-python-jemalloc/)

#### 计算机网络

- 《[计算机网络（第五版）](https://book.douban.com/subject/10510747/)》
- 《[Linux 的高级路由和流量控制 HowTo](https://lartc.org/)》这是一个非常容易上手的关于 iproute2、流量整形和一点 netfilter 的指南。
- [Red Hat Enterprise Linux Network Performance Tuning Guide](https://access.redhat.com/sites/default/files/attachments/20150325_network_performance_tuning.pdf)（网络调优文档）
- 网络工具：[Awesome Pcap Tools](https://github.com/caesar0301/awesome-pcaptools)，其中罗列了各种网络工具，能够让你更从容地调试网络相关的程序。
- [Making Linux TCP Fast](https://netdevconf.info/1.2/papers/bbr-netdev-1.2.new.new.pdf)（TCP调优论文）
- 网络协议
  - 学习通讯相关的RFC
  - 网络协议包含各个层的协议，而不仅仅是TCP/IP和HTTP协议。
    - 《[TCP 的那些事儿（上）](https://coolshell.cn/articles/11564.html)》和《[TCP 的那些事儿（下）](https://coolshell.cn/articles/11609.html)》
    - 《HTTP 权威指南 》
    - [Gitbook - HTTP/2 详解](https://legacy.gitbook.com/book/ye11ow/http2-explained/details)
    - [HTTP/2 for a Faster Web](https://cascadingmedia.com/insites/2015/03/http-2.html)
    - [Nginx HTTP/2 白皮书](https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf)
    - 还有 HTTP 的几种请求方式：短连接、长连接、Stream 连接、WebSocket 连接。

其他网络相关的资料，参见专栏。

- I/O模型，共五种模型：

  1. 阻塞 I/O
  2. 非阻塞 I/O
  3. I/O 的多路复用（select 和 poll）
  4. 信号驱动的 I/O（SIGIO）
  5. 异步 I/O（POSIX 的 aio_functions）

  其他信息见专栏。

#### Lock-free 的无锁编程

Lock-Free - 无锁技术越来越被开发人员重视，因为锁对于性能的影响实在是太大了，所以如果想开发出一个高性能的程序，你就非常有必要学习 Lock-Free 的编程方式。

[Is Parallel Programming Hard, And, If So, What Can You Do About It?](https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html) 这本免费的电子书堪称并行编程的经典书，必看。

其他信息见专栏。

注意，系统底层要是深下去是可以完全不见底的。而且内存方面的知识也是比较多的，所以，这里还是主要给出一些非常有价值的基础性的知识和技术。

### 第二部分：Java底层知识

#### Java 字节码相关

Java 最黑科技的玩法就是字节码编程，也就是动态修改或是动态生成 Java 字节码。Java 的字节码相当于汇编，其中的一些细节你可以从下面的这几个教程中学习。

- [Java Zone: Introduction to Java Bytecode](https://dzone.com/articles/introduction-to-java-bytecode) ，Java字节码入门教程，这篇文章图文并茂地向你讲述了 Java 字节码的一些细节。
- [Java Bytecode and JVMTI Examples](https://github.com/jon-bell/bytecode-examples)，这是一些使用 JVM Tool Interface 操作字节码的比较实用的例子。包括方法调用统计、静态字节码修改、Heap Taggin 和 Heap Walking。当然，一般来说，我们不使用 JVMTI 操作字节码，而是用一些更好用的库。这里有三个库可以帮你比较容易地做这个事。
  - [asmtools](https://wiki.openjdk.java.net/display/CodeTools/asmtools) - 用于生产环境的 Java .class 文件开发工具。
  - [Byte Buddy](http://bytebuddy.net/) - 代码生成库：运行时创建 Class 文件而不需要编译器帮助。
  - [Jitescript](https://github.com/qmx/jitescript) - 和 [BiteScript](https://github.com/headius/bitescript) 类似的字节码生成库。

使用字节码编程可以玩出很多高级玩法，最高级的还是在 Java 程序运行时进行字节码修改和代码注入。这个方式使用 Java 这门静态语言在运行时可以进行各种动态的代码修改，而且可以进行无侵入的编程。比如， 我们不需要在代码中埋点做统计或监控，可以使用这种技术把我们的监控代码直接以字节码的方式注入到别人的代码中，从而实现对实际程序运行情况进行统计和监控。

这种技术可以很魔法地把业务逻辑和代码控制分离开来。

如何实现该技术：

1. 学习Java Agent技术，Java Agent 使用的是 “[Java Instrumentation API](https://stackoverflow.com/questions/11898566/tutorials-about-javaagents)”，其主要方法是实现一个叫 premain() 的方法（嗯，一个比 main() 函数还要超前执行的 main 函数），然后把你的代码编译成一个 jar 文件。
2. 在 JVM 启动时，使用这样的命令行来引入你的 jar 文件：`java -javaagent:yourAwesomeAgent.jar -jar App.jar`。可参考文章有：
   - [Java Code Geeks: Java Agents](https://www.javacodegeeks.com/2015/09/java-agents.html)
   - 示例项目：[jvm-monitoring-agent](https://github.com/toptal/jvm-monitoring-agent) 或是 [EntryPointKR/Agent.java](https://gist.github.com/EntryPointKR/152f089f6f3884047abcd19d39297c9e)
   - ByteBuddy 相关的：[通过使用 Byte Buddy，便捷地创建 Java Agent](https://www.infoq.cn/article/Easily-Create-Java-Agents-with-ByteBuddy/)
   - 如何用 Java Agent 做监控：[ Stage Monitor](https://www.stagemonitor.org/)

#### JVM相关

- JVM 的规格说明书：[The Java Virtual Machine Specification Java SE 8 Edition](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)，[中文版](https://github.com/waylau/java-virtual-machine-specification)
- [JVM 解剖公园](https://shipilev.net/jvm/anatomy-quarks/)
- 学习 Java 底层原理还有 Java 的内存模型，官方文章是 [JSR 133](http://www.jcp.org/en/jsr/detail?id=133)
- 内存方面：
  - [The JSR-133 Cookbook for Compiler Writers](http://gee.cs.oswego.edu/dl/jmm/cookbook.html)，解释了怎样实现 Java 内存模型，特别是在考虑到多处理器（或多核）系统的情况下，多线程和读写屏障的实现。
  - [Using JDK 9 Memory Order Modes](http://gee.cs.oswego.edu/dl/html/j9mm.html)，讲了怎样通过 VarHandle 来使用 plain、opaque、elease/acquire 和 volatile 四种共享内存的访问模式，并剖析了底层的原理。
- 垃圾回收机制《[The Garbage Collection Handbook](https://book.douban.com/subject/6809987/)》（高难度）
- 怎么调优垃圾回收：[Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)
- [Quick Tips for Fast Code on the JVM](https://gist.github.com/djspiewak/464c11307cabc80171c90397d4ec34ef)，讲述了有写出更快的 Java 代码的几个小提示，值得一读。

### 第三部分：数据库相关

数据库相关的，包括：

- MySQL
- NoSQL
- Oracle《[Oracle Database 9i/10g/11g 编程艺术](https://book.douban.com/subject/5402711/)》

#### MySQL

- [MySQL 官方手册](https://dev.mysql.com/doc/)
- 《[高性能 MySQL](https://book.douban.com/subject/23008813/)》
- 《[MySQL 技术内幕：InnoDB 存储引擎](https://book.douban.com/subject/24708143/)》
- 《[数据库的索引设计与优化](https://book.douban.com/subject/26419771/)》
- 其他不错的MySQL文章：
  - [MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
  - [Some study on database storage internals](https://medium.com/@kousiknath/data-structures-database-storage-internals-1f5ed3619d43)
  - [Sharding Pinterest: How we scaled our MySQL fleet](https://medium.com/@Pinterest_Engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f)
  - [Guide to MySQL High Availability](https://www.mysql.com/cn/why-mysql/white-papers/mysql-guide-to-high-availability-solutions/)
  - [Choosing MySQL High Availability Solutions](https://dzone.com/articles/choosing-mysql-high-availability-solutions)
  - [High availability with MariaDB TX: The definitive guide](https://mariadb.com/wp-content/uploads/2019/04/mariadb-platform-high-availability-guide_whitepaper_1001.pdf)
- MySQL 的资源列表 : [Awesome MySQL](https://shlomi-noach.github.io/awesome-mysql/)
- 经验型的：
  - [Booking.com: Evolution of MySQL System Design ，Booking.com](https://www.percona.com/live/mysql-conference-2015/sessions/bookingcom-evolution-mysql-system-design) 的 MySQL 数据库使用的演化，其中有很多不错的经验分享，我相信也是很多公司会遇到的的问题。
  - [Tracking the Money - Scaling Financial Reporting at Airbnb](https://medium.com/airbnb-engineering/tracking-the-money-scaling-financial-reporting-at-airbnb-6d742b80f040) ，Airbnb 的数据库扩展的经验分享。
  - [Why Uber Engineering Switched from Postgres to MySQL](https://eng.uber.com/mysql-migration/) ，无意比较两个数据库谁好谁不好，推荐这篇 Uber 的长文，主要是想让你从中学习到一些经验和技术细节，这是一篇很不错的文章。
- 关于 MySQL 的集群复制：
  - [Monitoring Delayed Replication, With A Focus On MySQL](https://engineering.imvu.com/2013/01/09/monitoring-delayed-replication-with-a-focus-on-mysql/)
  - [Mitigating replication lag and reducing read load with freno](https://githubengineering.com/mitigating-replication-lag-and-reducing-read-load-with-freno/)
  - [Better Parallel Replication for MySQL](https://medium.com/booking-com-infrastructure/better-parallel-replication-for-mysql-14e2d7857813)
  - [Evaluating MySQL Parallel Replication Part 2: Slave Group Commit](https://medium.com/booking-com-infrastructure/evaluating-mysql-parallel-replication-part-2-slave-group-commit-459026a141d2)
  - [Evaluating MySQL Parallel Replication Part 3: Benchmarks in Production](https://medium.com/booking-com-infrastructure/evaluating-mysql-parallel-replication-part-3-benchmarks-in-production-db5811058d74)
  - [Evaluating MySQL Parallel Replication Part 4: More Benchmarks in Production ](https://medium.com/booking-com-infrastructure/evaluating-mysql-parallel-replication-part-3-benchmarks-in-production-db5811058d74)
  - [Evaluating MySQL Parallel Replication Part 4, Annex: Under the Hood](https://medium.com/booking-com-infrastructure/evaluating-mysql-parallel-replication-part-4-annex-under-the-hood-eb456cf8b2fb)
- 关于MySQL数据分区：
  - [StackOverflow: MySQL sharding approaches?](https://stackoverflow.com/questions/5541421/mysql-sharding-approaches)
  - [Why you don’t want to shard](https://www.percona.com/blog/2009/08/06/why-you-dont-want-to-shard/)
  - [How to Scale Big Data Applications](https://www.percona.com/sites/default/files/presentations/How%20to%20Scale%20Big%20Data%20Applications.pdf)
  - [MySQL Sharding with ProxySQL](https://www.percona.com/blog/2016/08/30/mysql-sharding-with-proxysql/)
- 其他
  - [MailChimp: Using Shards to Accommodate Millions of Users ](https://devs.mailchimp.com/blog/using-shards-to-accommodate-millions-of-users/)
  - [Uber: Code Migration in Production: Rewriting the Sharding Layer of Uber’s Schemaless Datastore](https://eng.uber.com/schemaless-rewrite/)
  - [Sharding & IDs at Instagram](https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c)
  - [Airbnb: How We Partitioned Airbnb’s Main Database in Two Weeks](https://medium.com/airbnb-engineering/how-we-partitioned-airbnb-s-main-database-in-two-weeks-55f7e006ff21)

#### NoSQL

- [NoSQL Distilled - NoSQL 精粹](https://book.douban.com/subject/25662138/)
- [NoSQL Databases: a Survey and Decision Guidance](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.nhzop4d23)
- [NoSQL Data Modeling Techniques](https://highlyscalable.wordpress.com/2012/03/01/nosql-data-modeling-techniques/)
- 其他资源见专栏。
- ElasticSearch资源：[GitHub: Awesome ElasticSearch](https://github.com/dzharii/awesome-elasticsearch)



### 第四部分：分布式架构

分布式系统涵盖的面非常广，具体来说涵盖如下几方面：

- 服务调度，涉及服务发现、配置管理、弹性伸缩、故障恢复等。
- 资源调度，涉及对底层资源的调度使用，如计算资源、网络资源和存储资源等。
- 流量调度，涉及路由、负载均衡、流控、熔断等。
- 数据调度，涉及数据复本、数据一致性、分布式事务、分库、分表等。
- 容错处理，涉及隔离、幂等、重试、业务补偿、异步、降级等。
- 自动化运维，涉及持续集成、持续部署、全栈监控、调用链跟踪等。

分布式注意点：

- 分布式系统之所以复杂，就是因为它太容易出错了。这意味着，你要把处理错误的代码当成正常功能的代码来处理。
- 开发一个健壮的分布式系统的成本是单体系统的几百倍甚至几万倍。这意味着，我们要自己开发一个，需要能力很强的开发人员。
- 非常健壮的开源的分布式系统并不多，或者说基本没有。这意味着，如果你要用开源的，那么你需要 hold 得住其源码。
- 管理或是协调多个服务或机器是非常难的。这意味着，我们要去读很多很多的分布式系统的论文。
- 在分布式环境下，出了问题是很难 debug 的。这意味着，我们需要非常好的监控和跟踪系统，还需要经常做演练和测试。
- 在分布式环境下，你需要更科学地分析和统计。这意味着，我们要用 P90 这样的统计指标，而不是平均值，我们还需要做容量计划和评估。
- 在分布式环境下，需要应用服务化。这意味着，我们需要一个服务开发框架，比如 SOA 或微服务。
- 在分布式环境下，故障不可怕，可怕的是影响面过大，时间过长。这意味着，我们需要花时间来开发我们的自动化运维平台。

#### 分布式架构入门

- [Scalable Web Architecture and Distributed Systems](http://www.aosabook.org/en/distsys.html)，这篇文章会给你一个大概的分布式架构是怎么来解决系统扩展性问题的粗略方法。
- [Scalability, Availability & Stability Patterns ](http://www.slideshare.net/jboner/scalability-availability-stability-patterns)，这个 PPT 能在扩展性、可用性、稳定性等方面给你一个非常大的架构设计视野和思想，可以让你感受一下大概的全景图。
- [==System Design Primer==](https://github.com/donnemartin/system-design-primer)，这个仓库主要组织收集分布式系统的一些与扩展性相关的资源，它可以帮助你学习如何构建可扩展的架构。

#### 分布式理论

- 教学课程：[An introduction to distributed systems](https://github.com/aphyr/distsys-class)，几乎涵盖了分布式系统方面的所有知识点，而且辅以简洁并切中要害的说明文字，非常适合初学者提纲挈领地了解知识全貌，快速与现有知识结合，形成知识体系。这也是一个分布式系统的知识图谱，可以让你看到分布式系统的整体全貌。

- [Byzantine Generals Problem拜占庭将军问题](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance)，拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。

  对于拜占庭问题来说，假如节点总数为 N，叛变将军数为 F，则当 N >= 3F + 1 时，问题才有解，即拜占庭容错（Byzantine Fault Tolerant，BFT）算法。拜占庭容错算法解决的是，网络通信可靠但节点可能故障情况下一致性该如何达成的问题。

  最早由卡斯特罗（Castro）和利斯科夫（Liskov）在 1999 年提出的实用拜占庭容错（Practical Byzantine Fault Tolerant，PBFT）算法，是第一个得到广泛应用的 BFT 算法。只要系统中有 2/3 的节点是正常工作的，则可以保证一致性。PBFT 算法包括三个阶段来达成共识：预准备（Pre-Prepare）、准备（Prepare）和提交（Commit）。

  - Dr.Dobb’s - The Byzantine Generals Problem
  - The Byzantine Generals Problem
  - Practicle Byzantine Fault Tolerance

  拜占庭容错系统研究中有三个重要理论：CAP、FLP 和 DLS。

  - [CAP 定理](https://en.wikipedia.org/wiki/CAP_theorem)：CAP 定理是分布式系统设计中最基础也是最为关键的理论。CAP 定理指出，分布式数据存储不可能同时满足以下三个条件：一致性（Consistency）、可用性（Availability）和 分区容忍（Partition tolerance）。 “在网络发生阻断（partition）时，你只能选择数据的一致性（consistency）或可用性（availability），无法两者兼得”。

    论点比较直观：如果网络因阻断而分隔为二，在其中一边我送出一笔交易：“将我的十元给 A”；在另一半我送出另一笔交易：“将我的十元给 B”。此时系统要不就是，a）无可用性，即这两笔交易至少会有一笔交易不会被接受；要不就是，b）无一致性，一半看到的是 A 多了十元而另一半则看到 B 多了十元。要注意的是，CAP 理论和扩展性（scalability）是无关的，在分片（sharded）或非分片的系统皆适用。

  - [FLP impossibility](http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/)，在异步环境中，如果节点间的网络延迟没有上限，只要有一个恶意的节点存在，就没有算法能在有限的时间内达成共识。但值得注意的是， [“Las Vegas” algorithms](https://en.wikipedia.org/wiki/Las_Vegas_algorithm)（这个算法又叫撞大运算法，其保证结果正确，只是在运算时所用资源上进行赌博，一个简单的例子是随机快速排序，它的 pivot 是随机选的，但排序结果永远一致）在每一轮皆有一定机率达成共识，随着时间增加，机率会越趋近于 1。而这也是许多成功的共识算法会采用的解决问题的办法。

  - 容错的上限，从[DLS](http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf) 论文 中我们可以得到以下结论：

    - 在部分同步（partially synchronous）的网络环境中（即网络延迟有一定的上限，但我们无法事先知道上限是多少），协议可以容忍最多 1/3 的拜占庭故障（Byzantine fault）。
    - 在异步（asynchronous）的网络环境中，具有确定性质的协议无法容忍任何错误，但这篇论文并没有提及 randomized algorithms，在这种情况下可以容忍最多 1/3 的拜占庭故障。
    - 在同步（synchronous）网络环境中（即网络延迟有上限且上限是已知的），协议可以容忍 100% 的拜占庭故障，但当超过 1/2 的节点为恶意节点时，会有一些限制条件。要注意的是，我们考虑的是"具有认证特性的拜占庭模型（authenticated Byzantine）"，而不是"一般的拜占庭模型"；具有认证特性指的是将如今已经过大量研究且成本低廉的公私钥加密机制应用在我们的算法中。

- 一致性方面的资源，见专栏。

#### 分布式经典书籍

- [Designing Data Intensive Applications（设计数据密集型应用）](https://book.douban.com/subject/27154352/)
- [Distributed Systems: Principles and Paradigms](http://barbie.uta.edu/~jli/Resources/MapReduce&Hadoop/Distributed%20Systems%20Principles%20and%20Paradigms.pdf)，中文翻译版为[《分布式系统原理与范型》（第二版）](https://item.jd.com/10079452.html)
- [Scalable Web Architecture and Distributed Systems](http://www.aosabook.org/en/distsys.html)，其中文翻译版 [可扩展的 Web 架构和分布式系统](http://nettee.github.io/posts/2016/Scalable-Web-Architecture-and-Distributed-Systems/)。
- [Principles of Distributed Systems](https://disco.ethz.ch/courses/podc_allstars/lecture/podc.pdf)，讲述了多种分布式系统中会用到的算法。

#### 分布式事务（分布式模型中最难部分）

分布式系统的事务只有 Paxos 算法是最好的。可参考文章《[分布式系统的事务处理](https://coolshell.cn/articles/10910.html)》。其余内容见专栏。

#### 分布式消息系统

见专栏。

#### 日志和数据

《[日志：每个软件工程师都应该知道的有关实时数据的统一概念](https://github.com/oldratlee/translations/blob/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/README.md)》

见专栏。

#### 分布式监控和跟踪

见专栏。

#### 数据分析

#### 分布式架构工程设计

- 分布式架构设计模式
- 分布式系统的故障测试
- 弹性伸缩
- 一致性哈希
- 数据库分布式
- 缓存
- 消息队列
- 关于日志方面
- 关于性能方面
- 关于搜索方面
- 各公司的架构实践

见专栏

### 第五部分：微服务

微服务架构文档：[Microservice Architecture ](https://martinfowler.com/articles/microservices.html)（[中译版](https://blog.csdn.net/wurenhai/article/details/37659335)）

《[微服务设计](https://book.douban.com/subject/26772677/)》

其他微服务架构的系列文章，见专栏。

架构推荐：

- 前端：React.js 或 Vue.js。
- 后端：Go 语言 + 微服务工具集 Go kit。
- 通讯：gRPC，这是 Google 远程调用的一个框架，它比 Restful 的调用要快 20 倍到 50 倍的样子。
- API：Swagger，Swagger 是一种 Restful API 的简单但强大的表示方式，标准的，语言无关，这种表示方式不但人可读，而且机器可读。可以作为 Restful API 的交互式文档，也可以作为 Restful API 形式化的接口描述，生成客户端和服务端的代码。
- 网关：Envoy 其包含了服务发现、负载均衡和熔断等这些特性，也是一个很有潜力的网关。当然，Kubernetes 也是很好的，而且它也是高扩展的，所以，完全可以把 Envoy 通过 Ingress 集成进 Kubernetes。这里有一个开源项目就是干这个事的 - [contour](https://github.com/projectcontour/contour)。
- 日志监控：fluentd + ELK 。
- 指标监控：Prometheus 。
- 调用跟踪：Jaeger 或是 Zipkin，当然，后者比较传统一些，前者比较时髦，最重要的是，其可以和 Prometheus 和 Envory 集成。
- 自动化运维：Docker + Kubernetes 。

#### 微服务和 SOA

微服务和 SOA的对比文章，见专栏。

微服务架构的优缺点，见专栏。

微服务和其它架构的一些不同和比较，见专栏。

#### 微服务设计模式和最佳实践

微服务的一些设计模式，见专栏。

[Awesome Microservices ](https://github.com/mfornos/awesome-microservices/)，一个各种微服务资源和相关项目的集中地。

[Microservices Resource Guide](https://martinfowler.com/microservices/) ，这个网页上是 Martin Fowler 为我们挑选的和微服务相关的文章、视频、书或是 podcast。

### 第六部分：容器化和自动化运维

#### Docker

[Docker官方介绍](https://docs.docker.com/engine/docker-overview/)

Docker相关的Web在线体验：[Katacoda Docker Playground ](https://www.katacoda.com/courses/docker/playground)或者是 [Play With Docker](https://training.play-with-docker.com/) 。

[Learn Docker](https://github.com/dwyl/learn-docker)

[超详细的Docker教程](https://docker-curriculum.com/)

[Docker官方文档](https://docs.docker.com/)

Docker底层技术细节文章：

- [Docker 基础技术：Linux Namespace（上）](https://coolshell.cn/articles/17010.html)
- [Docker 基础技术：Linux Namespace（下）](https://coolshell.cn/articles/17029.html)
- [Docker 基础技术：CgroupDocker ](https://coolshell.cn/articles/17049.html)
- [基础技术：AUFSDocker ](https://coolshell.cn/articles/17061.html)
- [基础技术：DeviceMapper](https://coolshell.cn/articles/17200.html)

其他Docker相关资源，见专栏。

Docker网络解决方案，见专栏。

Docker网络解决方案的性能对比，见专栏。

Docker 的性能问题相关的，见专栏。

Docker存储相关的，见专栏。

Docker运维，见专栏。

#### Docker最佳实践

- [Best Practices for Dockerfile ，Docker 官方文档里的 Dockerfile 的最佳实践。](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [Docker Best Practices ，这里收集汇总了存在于各个地方的使用 Docker 的建议和实践。](https://github.com/FuriKuri/docker-best-practices)
- [Container Best Practices ，来自 Atomic 项目，是一个介绍容器化应用程序的架构、创建和管理的协作型文档项目。](http://docs.projectatomic.io/container-best-practices/)
- [Eight Docker Development Patterns ，八个 Docker 的开发模式：共享基础容器、共享同一个卷的多个开发容器、开发工具专用容器、测试环境容器、编译构建容器、防手误的安装容器、默认服务容器、胶黏容器（如英文链接不能访问，可阅读中文版本）。](http://hokstad.com/docker/patterns)

#### Kubernetes

Kubernetes 是 Google 开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，也是 CNCF 最重要的项目之一，主要功能包括：

- 基于容器的应用部署、维护和滚动升级；
- 负载均衡和服务发现；
- 跨机器和跨地区的集群调度；
- 自动伸缩；
- 无状态服务和有状态服务；
- 广泛的 Volume 支持；
- 插件机制保证扩展性。

Kubernetes 发展非常迅速，已经成为容器编排领域的领导者。

《[Kubernetes Handbook](https://jimmysong.io/kubernetes-handbook/)》（推荐）

《[Kubernetes 指南](https://kubernetes.feisky.xyz/)》

《Kubernetes in Action》（推荐）

Kubernetes 的官方网站：Kubernetes.io，上面不但有[全面的文档 ](https://kubernetes.io/docs/home/)，也包括一个很不错的[ 官方教程 ](https://kubernetes.io/docs/tutorials/kubernetes-basics/)。

一些交互式教程：

[Katacoda](https://www.katacoda.com/courses/kubernetes)

[Kubernetes Bootcamp](https://kubernetesbootcamp.github.io/kubernetes-bootcamp/)

其他不错的文档，见专栏。

Kubernetes网络相关的文章，见专栏。

Kubernetes的CI/CD相关的文章，见专栏。

Kubernetes最佳实践，见专栏。

#### Docker 和 Kubernetes 资源汇总

[Awesome Docker](https://github.com/veggiemonk/awesome-docker)

[Awesome Kubernetes](https://github.com/ramitsurana/awesome-kubernetes)

虽然上面的这些系列非常全的罗列了很多资源，但是我觉得很不系统。对于系统的说明 Docker 和 Kubernetes 生态圈，我非常推荐大家看一下 The New Stack 为 Kubernetes 出的一系列的电子书或报告。见专栏。





### 第七部分：机器学习和人工智能

- 机器学习
- 人工智能

### 第八部分：前端开发

#### HTML5

- 《[HTML 5 权威指南](https://book.douban.com/subject/25786074/)》
- 《[HTML 5 Canvas 核心技术](https://book.douban.com/subject/24533314/)》
- 对于 SVG、Canvas 和 WebGL 这三个对应于矢量图、位图和 3D 图的渲染来说，给前端开发带来了重武器，很多 HTML5 小游戏也因此蓬勃发展。学习这三个技术，我个人觉得最好的地方是 MDN。
  - [SVG: Scalable Vector Graphics](https://developer.mozilla.org/en-US/docs/Web/SVG)
  - [Canvas API](https://developer.mozilla.org/kab/docs/Web/API/Canvas_API)
  - [The WebGL API: 2D and 3D graphics for the web](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API)
- GitHub几个资源列表：
  - [Awesome HTML5](https://github.com/diegocard/awesome-html5)
  - [Awesome SVG](https://github.com/willianjusten/awesome-svg)
  - [Awesome Canvas](https://github.com/raphamorim/awesome-canvas)
  - [Awesome WebGL](https://github.com/sjfricke/awesome-webgl)

#### CSS

- [MDN Web Doc - CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS)
- CSS书写规范，见专栏。
- CSS框架，Bootstrap、Semantic UI、Foundation、Bulma。
- HTML 标签给标准化的CSS库：Normalize、MiniRest.css、sanitize.css 和 unstyle.css。
- 关于更多的 CSS 框架，你可以参看[Awesome CSS Frameworks](https://github.com/troxler/awesome-css-frameworks) 上的列表。

#### Javascript

- 《[JavaScript 语言精粹](https://book.douban.com/subject/11874748/)》
- 《[JavaScript 忍者秘籍](https://book.douban.com/subject/26638316/)》
- 《[Effective JavaScript](https://book.douban.com/subject/25786138/)》
- [阮一峰翻译的 ES6 的教程](http://es6.ruanyifeng.com/)
- [ECMAScript 6 Tools](https://github.com/addyosmani/es6-tools) ，这是一堆 ES6 工具的列表，可以帮助你提高开发效率。
- [Modern JS Cheatsheet](https://mbeaudru.github.io/modern-js-cheatsheet/)
- 其他见专栏

#### 浏览器工作原理

见专栏。

#### 网络协议

[Gitbook - HTTP/2 详解](https://legacy.gitbook.com/book/ye11ow/http2-explained/details)

HTTP 的几种请求方式：短连接、长连接、Stream 连接、WebSocket 连接。

#### 性能优化

《[高性能网站建设指南：前端工程师技能精髓](https://book.douban.com/subject/26411563/)》

其他见专栏。

#### 前端框架

- 《[React中文教程](https://react.docschina.org/)》
- 《[JS 函数式编程指南中文版](https://jigsawye.gitbooks.io/mostly-adequate-guide/content/)》
- [Awesome React](https://github.com/enaqx/awesome-react) ，这是一些 React 相关资源的列表，很大很全。
- [React/Redux Links](https://github.com/markerikson/react-redux-links)，这也是 React 相关的资源列表，与上面不一样的是，这个列表主要收集了大量的文章，其中讲述了很多 React 知识和技术，比上面的列表好很多。
- [React Rocks ](https://react.rocks/)，这个网站主要收集各种 React 的组件示例
- [Vue 官方文档（中文版）](http://vuejs.org/guide/)
- [新手向：Vue 2.0 的建议学习顺序](https://zhuanlan.zhihu.com/p/23134551)
- [Awesome Vue](https://github.com/vuejs/awesome-vue)

#### UI / UX 设计 

见专栏。

### 第九部分：信息源

各大公司的技术 Blog

还有相关的论文集散地。





**你不需要特别努力，只需要日进一步，3-5 年后，你就会发现，绝大多数人都在你身后很远的地方了。**
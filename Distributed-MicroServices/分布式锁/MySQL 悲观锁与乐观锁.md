# MySQL 的悲观锁与乐观锁



## MySQL 的悲观锁

在 MySQL中，通过 for update 语句来实现悲观锁。

==FOR UPDATE 仅适用于InnoDB存储引擎，且必须在事务区块(BEGIN/COMMIT)中才能生效。==

### for update 语句测验

在未做任何处理的情况下，分别在不同的查询窗口，执行下述同一个语句：

```mysql
select * from category where id=130358 for update
```

会发现和普通select语句没有任何区别。两个查询窗口都可以查询出结果。这是因为：

mysql默认情况下每个sql都是单独的一个事务，并且是自动提交事务。

可以执行下述语句查看当前事务是否自动提交情况：

```mysql
select @@autocommit
```

此时通过下述语句，设置成非自动提交事务：

```mysql
select @@autocommit;
set autocommit=0;
select @@autocommit;
```

（注意：上述设置只针对当前查询窗口有效，重新打开的新窗口依然是自动提交事务的。）

然后在其中的一个查询窗口中执行上述select语句，再到另一个查询窗口执行同样的语句，会发现数据被锁住，处于正在处理的状态。

可以选中并执行下述语句来释放锁：

```mysql
commit;
```

此时，另一个等待中的查询正常获取到了数据。

同时，==锁只会锁住 update 语句==，也就是说当使用 select ... for updae 语句锁定了数据时，此时将for update 去掉，只执行select语句，依然能够查询出记录。

例如，上述中在两个不同的查询窗口同时执行上述select .. for update 语句，其中一个会等待，此时如果只是执行如下语句：

```mysql
select * from category where id=130358
```

不加后面的 for update，此时仍然可以查询出数据。

注意：使用 for update 语句虽然能够查询出数据，但是一定不要忘记commit，否则会阻塞其他事务处理同一批数据。



### for update 需要注意点

InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！

我们使用给name字段加索引的方法，使表锁降级为行锁，==不幸的是这种方法只针对 *属性值重复率低* 的情况。当属性值重复率很高的时候，索引就变得低效，MySQL 也具有自动优化 SQL 的功能。低效的索引将被忽略。就会使用表锁了==。

==重点：==

- 在具有索引的列作为查询条件时，for update 语句使用的是行锁，锁定的是对应的索引的那条记录；
- 如果是没有索引的其他列作为查询条件时，for update 语句会由行锁升级为表锁，整个表都会被锁定。

总结：

- 使用 for update 语句时，一定要使用索引列作为查询条件，否则一旦查询出结果，将会锁住整个表；
- 锁只会锁住要更新的语句 for update；
- 如果没有满足条件的结果，不会锁表；
- 上述的commit语句只是为了在查询窗口中进行测验，在实际项目中，通过代码实现事务的开启和提交来达到commit的效果。
- mysql进行row lock还是table lock只取决于是否能使用索引，而 使用’<>’,'like’等操作时，索引会失效，自然进行的是table lock；

### 补充：索引失效的情况

什么情况索引会失效：

**1.负向条件查询不能使用索引**

负向条件有：!=、<>、not in、not exists、not like 等。

**2.索引列不允许为null**

单列索引不存null值，复合索引不存全为null的值，如果列允许为 null，可能会得到不符合预期的结果集。

**3.避免使用or来连接条件**

应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描，虽然新版的MySQL能够命中索引，但查询优化耗费的 CPU比in多。

**4.模糊查询**

前导模糊查询不能使用索引，非前导查询可以。

以上情况索引都会失效，所以进行for update的时候，会进行table lock。

参考：https://juejin.im/post/5b14e0fd6fb9a01e8c5fc663







## MySQL 的乐观锁

是解决数据不一致性的方案。悲观锁的实质是利用了Mysql的内置锁，而乐观锁，是通过在where条件上的逻辑控制来实现数据一致性的。

乐观锁的实现，大多是where条件中，要有未更新之前的条件限定，从而避免更新的不是之前查询出来的数据。典型的，如sqlserver中的rowversion类型字段作为where条件。

  

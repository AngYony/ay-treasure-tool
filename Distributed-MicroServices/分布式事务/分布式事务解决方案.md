# 分布式事务解决方案

分布式系统，最重要的一点是要保证同时成功或同时失败。



## 常见分布式事务解决方案

- 两阶段提交（2PC, Two-phase Commit）
- TCC 补偿模式
- 基于本地消息表实现最终一致性
- 最大努力通知
- **基于可靠消息最终一致性方案 **



## 两阶段提交（2PC）

不适用于解决分布式事务，原理是通过数据库事务进行分段限定，简单点来说就是开启事务和提交事务分为两个阶段。例如，需要调用3个服务，那么第一个阶段中，每个服务都需要先开启事务，也就是发送事务预处理请求，各个节点执行完并不会提交本地数据库事务，而是反馈给调用者，等待调用者的响应。等业务逻辑处理完后，在第二个阶段中，各个节点收到响应，执行commit操作，从而完成提交。

缺点：参与者 进行本地事务提交后才会释放资源。这样的**过程会比较漫长，对性能影响比较大**。一旦中间出现问题，参与者会一直阻塞下去。



## TCC 补偿模式

通过业务代码的模式，实现2PC中使用事务出现的锁问题。

也就是对于数据库的操作都是直接提交是持久化操作，如果发现需要回滚的时候，就对数据库的数据进行反向处理。例如：扣减库存，再增加积分，一旦发生了错误回滚时，就直接将之前扣减的库存加回去，增加过的积分，再减去就行了。

如果采用TCC分布式事务，需要引入第三方框架才能实现完整的功能。

TCC要解决数据一致性问题，仍然会在数据端加锁，支撑不了高并发。

总结一下，你要玩儿TCC分布式事务的话：

1. 首先需要选择某种TCC分布式事务框架，各个服务里就会有这个TCC分布式事务框架在运行。
2. 然后你原本的一个接口，要改造为3个逻辑，Try-Confirm-Cancel。

- 先是服务调用链路依次执行Try逻辑
- 如果都正常的话，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务
- 如果某个服务的Try逻辑有问题，TCC分布式事务框架感知到之后就会推进执行各个服务的Cancel逻辑，撤销之前执行的各种操作。
- 这就是所谓的TCC分布式事务。
- TCC分布式事务的核心思想，说白了，就是当遇到下面这些情况时，

1. 某个服务的数据库宕机了
2. 某个服务自己挂了
3. 那个服务的redis、elasticsearch、MQ等基础设施故障了
4. 某些资源不足了，比如说库存不够这些

- 先来Try一下，不要把业务逻辑完成，先试试看，看各个服务能不能基本正常运转，能不能先冻结我需要的资源。
- 如果Try都ok，也就是说，底层的数据库、redis、elasticsearch、MQ都是可以写入数据的，并且你保留好了需要使用的一些资源（比如冻结了一部分库存）。
- 接着，再执行各个服务的Confirm逻辑，基本上Confirm就可以很大概率保证一个分布式事务的完成了。
- 那如果Try阶段某个服务就失败了，比如说底层的数据库挂了，或者redis挂了，等等。
- 此时就自动执行各个服务的Cancel逻辑，把之前的Try逻辑都回滚，所有服务都不要执行任何设计的业务逻辑。保证大家要么一起成功，要么一起失败。

### 终极大招

- 如果有一些意外的情况发生了，比如说订单服务突然挂了，然后再次重启，TCC分布式事务框架是如何保证之前没执行完的分布式事务继续执行的呢？
- TCC事务框架都是要记录一些分布式事务的活动日志的，可以在磁盘上的日志文件里记录，也可以在数据库里记录。保存下来分布式事务运行的各个阶段和状态。
- 万一某个服务的Cancel或者Confirm逻辑执行一直失败怎么办呢？
- 那也很简单，TCC事务框架会通过活动日志记录各个服务的状态。
- 举个例子，比如发现某个服务的Cancel或者Confirm一直没成功，会不停的重试调用他的Cancel或者Confirm逻辑，务必要他成功！
- 当然了，如果你的代码没有写什么bug，有充足的测试，而且Try阶段都基本尝试了一下，那么其实一般Confirm、Cancel都是可以成功的！
- 如果实在解决不了，那么这个一定是很小概率的事件，这个时候发邮件通知人工处理
- seata、 go-seata

### 优点

1. 解决了跨服务的业务操作原子性问题，例如组合支付，订单减库存等场景非常实用
2. TCC的本质原理是把数据库的二阶段提交上升到微服务来实现，从而避免了数据库2阶段中锁冲突的长事务低性能风险。
3. TCC异步高性能，它采用了try先检查，然后异步实现confirm，真正提交的是在confirm方法中。

### 缺点

1. 对微服务的侵入性强，微服务的每个事务都必须实现try，confirm，cancel等3个方法，开发成本高，今后维护改造的成本也高。
2. 为了达到事务的一致性要求，try，confirm、cancel接口必须实现等幂性操作。
   （定时器+重试）
3. 由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长，建议采用redis的方式来记录事务日志。
4. tcc需要通过锁来确保数据的一致性，会加锁导致性能不高。



## 基于本地消息表实现最终一致性

本地消息表这个方案最初是eBay提出的，此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。



## 基于可靠消息最终一致性方案

使用MQ中的事务消息。



## 最大努力通知

最大努力通知方案的目标：
　　目标：发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。
具体包括：
　　1、有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。
　　2、消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。
最大努力通知与可靠消息一致性有什么不同？
　　1、解决方案思想不同
　　可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。
　　最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。
2、两者的业务应用场景不同
　　可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。
　　最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。
3、技术解决方向不同
　　可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。
　　最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。
# MySQL性能优化建议

==注意：本文仅适用于MySQL，SQL Server未验证是否同样适用。==

对数据库进行调优，可以进行选择的维度有：

- 选择适合的DBMS
- 优化表设计
- 优化逻辑查询，即：SQL 查询优化
- 优化物理查询，即：索引优化
- 库级优化，即：从数据库本身进行优化。比如读写分离。



## 优化表设计

- 表结构尽量遵循第三范式原则。
- 合理的选择字段的数据类型。比如：char和varchar。
- 必要的时候增加冗余字段（反范式）



## 优化逻辑查询

- where子句中，“=”左边的尽量少用或不用函数。在 WHERE 子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。例如：`WHERE SUBSTRING(comment_text, 1,3)='abc'`使用`WHERE comment_text LIKE 'abc%'`代替。
- 



## 索引优化

从功能逻辑上说，索引有4种：

1. 普通索引：是基础的索引，没有任何约束，主要用于提高查询效率。
2. 唯一索引：在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。
3. 主键索引：在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引。
4. 全文索引：用的不多，通常可以采用专门的全文搜索引擎，比如 ES(ElasticSearch) 和 Solr。

在一张数据表中只能有一个主键索引，这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。但可以有多个普通索引或者多个唯一索引。

### 聚集索引与非聚集索引

按照物理实现方式，索引可以分为 2 种：

1. 聚集索引：表中数据行按索引（可以是主键索引）的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。
2. 非聚集索引，也称为二级索引或者辅助索引。在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。非聚集索引不会把索引指向的内容像聚集索引一样直接放到索引的后面，而是维护单独的索引表（只维护索引，不维护索引指向的数据），为数据检索提供方便。

聚集索引与非聚集索引的区别：

- 聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。
- 一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。
- 使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。

**注意：主键索引不一定是聚集索引，也可以是非聚集索引。只是按照实现的方式不同分为了聚集和非聚集索引。同样，聚集索引也不一定是主键索引，不是主键的列，依然可以创建为聚集索引。**

### 联合索引

索引还可以按照字段个数进行划分，分成单一索引和联合索引。

创建联合索引时，需要注意创建时的顺序问题。联合索引存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。比如，创建了联合索引 (x, y, z)，如果查询条件是 WHERE x=1 AND y=2 AND z=3，就可以匹配上联合索引；如果查询条件是 WHERE y=2，就无法匹配上联合索引。

**使用联合索引的时候，按照什么顺序创建索引，就只能按照这个顺序使用索引。字段顺序不能乱，查询字段可以少，但只能从右侧开始减少，不能从左侧。同时，在创建联合索引的时候，最好是根据字段值的区分度来排序，区分度最大的字段放在联合索引的最左侧，区分度最小的字段放在联合索引的最右侧。**

### 索引优化的建议

 如果你使用了WHERE子句，对于某个字段进行了条件筛选，那么这个字段你可以通过建立索引的方式进行SQL优化。因为我们在进行SQL优化的时候，应该尽量避免全表扫描。所以当我们使用WHERE子句对某个字段进行了条件筛选时，如果我们没有对这个字段建立索引，就会进入到全表扫描，因此可以考虑对这个字段建立索引。

- 数据重复度高的字段（重复度超过10%的），通常不需要创建索引。比如“性别”这个字段。
- 在 WHERE 子句中要尽量避免对字段进行函数运算或表达式计算，否则会让字段的索引失效。
- 在为多个字段创建联合索引时，联合索引中的字段顺序要和where子句中使用该字段的顺序一致。
- 索引不是越多越好。
- 采用聚集索引进行数据查询，比使用非聚集索引的查询效率略高。如果查询次数比较多，还是尽量使用主键索引进行数据查询。
- 可以为频繁作为 WHERE条件的字段添加索引，尤其在数据表大的情况下。不管是查询，还是修改，或者删除操作，where条件列都应该创建索引。
- 需要经常 DISTINCT、GROUP BY 和 ORDER BY 的列添加索引。
- 多表连接的时候，要对连接的字段创建索引，并且该字段在多张表中的类型必须一致。
- 频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。
- 索引列不要进行任何的表达式的计算，否则索引会失效。失效案例：`WHERE comment_id+1 = 900001`。（原因是一旦对索引列进行了表达式的计算，需要把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。）
- 索引列不要进行任何的函数调用，否则索引会失效。
- 在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。（因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效）
- 当我们使用 LIKE 进行模糊查询的时候，后面的LIKE表达式不能是以 %开头。（ 对 LIKE '%X' 会让索引失效）
- 索引列尽量设置为 NOT NULL 约束。判断索引列是否为 NOT NULL，往往需要走全表扫描，因此我们最好在设计数据表的时候就将字段设置为 NOT NULL 约束比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 ('')。
- 在使用联合索引的时候要注意最左原则，最左原则也就是需要从左到右的使用索引中的字段，一条 SQL 语句可以只使用联合索引的一部分，但是需要从最左侧开始，否则就会失效。
- 不要在WHERE子句后面对索引字段做函数处理，同时也避免对索引字段进行数据类型转换，否则会造成索引失效。
- 避免在索引字段上使用<>，!=，以及对字段进行NULL判断（包括 IS NULL, IS NOT NULL），否则会造成索引失效。
- 在索引字段后，慎用IN和NOT IN，如果是连续的数值，可以考虑用BETWEEN进行替换。





# 功能架构训练营笔记



详细需求：

使用者有两类：

- 配置管理员，包含的功能有：
  - 配置资源，将系统中需要进行权限保护的资源配置到系统，可以对资源添加权限，通过分配给不同的用户或角色达到保护资源的目的。这些资源包括：
    - API的资源（类似于菜单），每个API请求作为一个资源
    - DB实体的资源，包括这个实体上的所有字段列，可以控制字段级别的新增、修改、删除操作。
  - 配置权限，将一个或者多个资源绑定在一个权限上，以达到通过一个权限控制多个资源保护的目的。权限包括：
    - API可以配置为一个权限
    - 一个实体可以配置为一个权限，允许新增和删除两个实体级别的权限，同时每个实体的每个字段都有一个允许修改的权限。
    - 一个权限可以有一个或者多个资源
  - 配置角色，在系统中添加角色用来管理用户和权限。包括：
    - 根据角色名称添加角色
    - 为角色添加权限
    - 为角色绑定用户
  - 配置用户，可以在系统中添加用户，对已经存在的用户进行关联。包括：
    - 新增系统用户
    - 为用户添加权限
    - 为用户绑定角色
- 普通用户，包含的功能有：
  - 注册，允许用户注册成为系统用户
  - 登录，用户登录之后联系系统内的身份，取得可以访问资源的权限
  - 访问资源（如API、菜单等），用户对系统内的资源进行访问，系统对没有权限的资源访问请求进行拦截。
  - API资源无权限返回403
  - 实体资源的操作应该返回错误信息将用户引导到无权限访问的页面进行展示
  - 













通过OPM对业务进行分析和建模，通过RGCA四步方法来进行架构设计。



## 架构的底层逻辑

### 系统思维（1.1课时）

弄清楚什么是系统？ 系统是由形式（静态结构）和功能（动态结构，它能做什么）两部分构成，即若干部分相互联系、相互作用，形成的具有某些功能的整体。系统由多个实体组成，同时系统也是另一个系统中的实体。这里的功能不是指过于细节的功能(过于细节的称为特性)，而是站在顶层基于全局的、一句话就能概括描述的系统的用途或功能。

- 产品：产品是能够交换或具备交换潜力的事物。 



### 理解功能 （1.2课时）

站在架构师的视角，如何通过这个功能来识别出这个系统为用户创造出利益。

系统通过为用户提供功能传递交付价值（价值=有成本的利益），离利益最接近的那个活动，称为**关键活动**，用来支持该活动运转的其他活动称为**支持活动**。

一个系统提供的功能有很多，要能够区分出哪些是关键功能和主要功能。

#### 系统目标的陈述

如何更清晰的描述系统是怎么样传递价值的，它指出了系统为体现其价值而打算完成的事情，若能完成这件事情，者表明系统取得了真正的成功。

to ... by ... using...

```
为了... 【对意图所做的陈述，企业的需求可以通过这里进行描述】
通过... 【对功能所做的陈述】
使用... 【对形式所做的陈述，系统的名称】
```

例如：

```
为了获得更多的客户交易，提升惬意利润水平
通过维护更完整、更详细的客户资源管理、加强客户之间的互动与沟通
使用crm管理系统
```



### 系统的分解（1.3课时）

当需要了解系统的内部结构时，需要对系统进行拆解。

（对于一个全新的系统，想要了解它时，不能上来就看代码。而是由整体到局部，由面到点，一步步拆解来看。）

系统的分解包括：形式结构的分解（实体分解）和功能过程的分解（功能分解）。

通常系统本身属于第0层，而实体和功能的分解属于第一层。

#### 实体分解

对系统可见的形式实体进行分解，这些形式实体往往对应于解决方案中的各个类库或者目录，以无代码埋点权限系统为例：

- UI 提供UI来管理资源、权限跟用户与角色的绑定
- Core 提供资源扫描、资源注册的核心抽象定义
- ActionAccess 对 Web API进行扫描
- EntityAccess 对 EF Core 进行 ORM Entity资源的扫描
- Security.Identity 对 asp.net core identity模块的桥接 Permission 功能
- Aspnetcore.Identity 默认的用户角色管理模块

#### 功能分解

通过UML用例将系统的功能进行分解。 

#### 分解的框架

通常对系统进行以下几种分类：

- 元素：也可以统称为对象。对象通常分为以下几类：
  - 主体对象：能够体现用户角色
  - 事物对象：在业务场景中发现的一些事物，通常是通过观察去发现的，也称为业务对象。
  - 支持对象：在系统中用来支持业务场景发生的一些工具，往往需要架构师来发明，常以or结尾，比如Implementor。 
- 连接：元素与元素之间的关系。
- 过程：过程改变对象的状态体现系统的价值，即对象与对象之间是如何协作的。系统被分解的整体的功能是由哪些过程组成来完成交付的。



### 理解架构（1.11课时）

架构作名词来说时，系统架构是定义系统的结构、行为以及其他视图的概念模型。

当架构作为动词来说时，更多地在说“架构过程”，也就是如何产生这样一套架构描述。

#### 4+1 视图模型

- **场景视图**，用于描述系统的参与者与功能用例间的关系，反映系统的最终需求和交互设计。 通常使用UML用例图来表示，代表用户和系统之间操作的使用的场景，偏向于用户场景。
- 逻辑视图，主要用来支持功能性需求，系统应该提供什么样的服务给用户。偏向于功能需求，基于功能的每个组件如何排布，组件与组件之间的关系。
- 开发视图，用于开发使用的，描述组件之间的关系的，偏向于开发期的质量属性，可扩展性、可重用性、可移植性、易理解性、易测试性。
- 物理视图，偏向于安全和部署需求。
- 处理视图，也称为进程视图。用于描述系统软件组件之间的通信时序，数据的输入输出。系统之间各进程调用关系。更多的强调运行期间的质量属性，系统有哪些处理进程，进程与进程之间是如何交互的 ，当并发、吞吐上来时，进程之间的运行是否依旧保持良好。如：易用性、性能、可伸缩性、持续可用性、鲁棒性、安全性等。在UML中通常由时序图和流程图表示。 

 

#### 组件化思维

组件化思维是一种应用复杂系统的分解方式，把大的系统分解为组件。

一个组件由多个实体组成。



#### 优秀架构

优秀架构的一些标准



#### 架构风格

单体架构风格：

- 分层架构风格

- 管道架构风格

  每个管道通常是单向和点对点的（而不是广播的），接收来自一个源的输入，并总是输出到另一个源上。

- 微核架构风格

  一个核心组件 + 多个插件组件

  

分布式架构风格：

- 基于服务的架构风格（ SOA）

  将多个组件包装成一个服务对外提供。

- 事件驱动的架构风格

- 微服务架构风格



#### 架构的过程

RGCA：需求分析（Requirement）、目标定义（Goal）、概念提取（Concept），架构设计（Architecture）的4个进程。每个过程所产生的输出物会作为后一个过程的输入继续分析和设计。



OPM（Object Process Methodology） ：过程+对象，或者简单认为是UML+过程

OPL



面向对象：是把构成问题的各个事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述一个事物在整个解决问题的步骤中的行为。

面向过程：是把问题分解为各个步骤，关心的是如何通过步骤的实现来解决问题。

 





- 架构师与架构
  - 架构的六大关系
    - 架构师与公司
    - 架构师与老板
    - 架构师与产品经理
    - 架构师与程序员
    - 架构师与测试
    - 架构师与运维



## 重新学习面向对象

### 为什么要学习面向对象?

提高复杂代码的开发和设计能力

 架构设计是一个发现和发明抽象的过程。我们需要对现实世界进行观察、分类；找到重要的那些元素、他们的职责、以及彼此之间的联系。然后在软件中创建一个映射，能够模拟现实世界的真实运行。

### 理解复杂系统

复杂的系统，是由很多高度相关，高度互联或高度混杂的元素或实体所组成的系统。

### 面向对象（OO）

OO如何应对复杂系统？

- 通过抽象，提取本质、关键元素（对象与交互）
- 通过类的封装实现信息隐藏和逻辑分割
- 通过物理模块封装对系统进行物理分割
- 通过层次结构进一步降低复杂度

 OO如何应对变化？

- 单一职责原则
- 接口隔离原则
- 开闭原则（如抽象工厂模式）
- 里氏替换原则
- 依赖倒置原则，依赖于抽象，不要依赖于具体的实现。

### 抽象

对于给定的问题域决定一组正确的抽象，就是面向对象设计的核心问题。

- 实体抽象：一个对象，代表了问题域或解决方案域实体的一个有用的模型。
- 动作抽象：一个对象，提供了一组通用的操作，所有这些操作都执行同类的功能。
- 虚拟机抽象：一个对象，集中了某种高层控制要用到的所有操作，或者这些操作将利用某种更低层的操作集。
- 偶然抽象：一个对象，封装了一组相互间没有关系的操作。

在面向对象的思想中鼓励实体抽象，因为它直接对应给定问题域的词汇。

在OPM中还鼓励进行动作的抽象。

#### 提升抽象能力的方式

- 阅读和总结
- 命名训练
- 建模训练

#### 分类

- 经典分类：某一个或者某一组拥有共同属性的实体构成一类
- 概念聚集：对某个事物先形成概念描述，然后再根据这些概念描述进行分类
- 原型理论：我们根据明确的概念对事物进行分组

#### 过程抽象

通过功能意图的挖掘来寻找替代过程。



### 封装与模块化

抽象和封装是互补的概念：抽象关注的是对象可以观察到的行为，而封装关注这种行为的实现。

封装是一个过程，它分隔构成抽象的结构和行为的元素。封装的作用是分离抽象的概念接口及其实现。

模块化是封装之后的结果。

#### 关注点分离

#### 模块化

将一个程序分割到一些不同的组件中，这可以在某种程度上减少它的复杂性。

对于一个给定的问题决定一组正确的模块，这和决定一组正确的抽象的难度几乎差不多。

每个模块的结构都应该足够简单，这样它就能被完全理解。

应该能够在不知道其他模块的实现方法，并不会影响其他模块的行为的情况下，修改某个模块的实现。

REP、CCP与CRP对模块的封装提到了具体的指导。

模块化需要符合的要求：

- REP（复用、发布等同原则）：重要的粒度就是发布的粒度。

- CCP（共同闭包原则）：所有可能被一起修改的类集中在一起，两个总是被一起修改的类应该放入同一组件。
- CRP（共同复用原则）：所有可能被一起复用的类集中在一起，两个总是被一起复用的类应该放入同一组件。
- 高内聚、低耦合



### 层次结构

系统的层次结构，是一组实体的层次结构

分解：把系统当成一个实体，分解成为更多小的实体

体系：把系统内的实体按某个层次和位阶来进行排列，这些层次是上下顺序排列起来的。

层级分解：分解 + 体系

子系统 =》 模块 =》类



### 类与对象

对象是一个具有状态、行为和标识符的实体。结构和行为类似的对象定义在它们共同的类中。

类与类之间的关系：

- 依赖
- 关联
- 聚合
- 组合



### 面向过程分解

分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现。

在过程分解中我们同样可以运用抽象、封装和层次结构等手段，来帮忙进行系统的分析和设计。

#### 过程聚集



### 面向对象分析

- 经典方法
- 行为分析
- 领域分析
- 用例分析
- 结构化分析
- OPM对象过程分析

面向对象分解最后得到类，需要经历以下四个过程：

1. 识别元素：确定一些关键的元素，这些元素将在特定的抽象层次上描述解决方案。
2. 识别协作：确定元素间的协作，其目的是描述已识别的元素如何协同工作，以提供系统的行为需求。
3. 识别关系
4. 识别语境

#### 识别元素

这些元素将在特定的抽象层次上描述解决方案。

在问题域的描述中，找到关键元素。

#### 识别协作

其目的是描述已识别的元素如何协同工作，以提供系统的行为需求。此处主要是定义出系统中的职责并将其合理地分配到对象上。

在分配职责时需要注意，应该将职责分配给该职责的执行者。而不是发起者。所以我们需要明确区分该职责的发起者和执行者。

在分配职责时遵循的一些原则：

- 元素应该具有平衡的职责，一个元素不应该什么都做（单一职责原则）。
- 元素应该具有一致的职责。如果元素的一些职责是无关联的，那么它应该分成两个或多个元素。
- 应该没有两个元素具有相同或非常类似的职责。
- 为每个元素定义的职责应该支持该元素所参与的场景。
- 职责不简单或者不清楚意味着给定的抽象没有得到很好的定义。

#### 识别关系

- 识别关联，初步识别元素之间的语义联系。
- 细化关联，成为语义上更丰富的关系（即组合、聚合、关联、依赖等）。

 四个关系的强弱：组合>聚合>关联>依赖；

依赖关系通常只表明只是在某一个方法中有使用，是最弱的关系。

关联通常是在对象的属性上会建立导航关系（1V1或者1V多）

聚合说明的是一种更强的关联，即组成关系，但是彼此都可以独立存在。权限必须至少由一个资源组成，但是资源独立也可以存在。

组合关系也是一种关联，A包含B，但是B单独存在没有意义。是一种最强的关系。

### 面向对象分析总结

面向对象的分析从问题域开始，需要给定问题域和确定域边界。

在DDD领域驱动设计方法里面，重点也是首先要根据业务识别好问题域，针对问题域简历限界上下文。

由于面向对象过分强调对象，而忽视过程，因此会导致在方法论上要求先识别元素，再识别职责，协作在元素之后，会增加面向对象分析的难度。





## OPM对象过程分析

OPM与UML

OPM= 面向对象+面向过程

OPM核心概念是从功能开始





- 认识概念建模
- UML建模
- OPM介绍
- OPM的核心概念
- 从功能开始
  - 受益者
  - 过程影响对象
- 链接联系事物
- 支持链接
- 变换链接
- 放大与细化
- 动态特性
- 结构特性
- 控制复杂度
- 最佳建模实践
- 





## RGCA架构设计过程

需求 ，目录，概念，架构



## 逆向架构

从已经存在的系统，画出架构图



## 架构案例















